# L3: 多代理协作与工具集成

**学习目标**: 构建专业化AI代理团队，实现复杂任务的协作处理  
**预计用时**: 4-5小时  
**核心转变**: 从"单兵作战"思维 → "团队协作"思维

*💡 这一章将带你进入LangGraph的精髓——多代理协作。你将学会如何让不同的AI代理像专业团队一样分工合作，每个代理都有自己的专长，共同解决复杂问题。*

---

## 🌟 开篇：团队的力量

### 令人着迷的协作现象

想象一下，你要求一个AI系统"分析最近的科技趋势并写一份投资建议报告"，然后这个系统：

```python
# 用户请求："分析最近的科技趋势并写一份投资建议报告"

# 🔍 研究员代理启动
"正在搜索最新的科技新闻、论文和市场数据..."

# 📊 分析师代理接手  
"正在分析技术发展趋势和市场潜力..."

# ✍️ 撰写员代理开始工作
"正在撰写结构化的投资建议报告..."

# 🔍 质检员代理验证
"正在验证数据准确性和逻辑一致性..."

# 📈 最终输出
"完成！这是一份包含最新数据分析的专业投资建议报告。"
```

**这种协作是如何实现的？** 🤔

每个代理都有自己的专业领域：
- 🔍 **研究员**：擅长信息搜索和数据收集
- 📊 **分析师**：擅长数据分析和趋势判断  
- ✍️ **撰写员**：擅长内容创作和结构化表达
- 🔍 **质检员**：擅长验证和质量控制

它们通过共享的工作状态进行协作，就像现实中的专业团队一样！

### 为什么需要多代理？

**单一AI的局限性**：
```python
# 单一AI处理复杂任务
def single_ai_solution(task):
    # 需要同时具备所有能力
    research_data = ai_research(task)      # 搜索能力
    analysis = ai_analyze(research_data)   # 分析能力  
    report = ai_write(analysis)            # 写作能力
    quality = ai_check(report)             # 质检能力
    return report if quality > 0.8 else "失败"
```

**问题显而易见**：
- ❌ **能力稀释**：什么都会，但什么都不精
- ❌ **上下文丢失**：长任务中容易遗忘前面的信息
- ❌ **错误传播**：一个环节的错误影响整个结果
- ❌ **难以优化**：无法针对特定环节进行专门优化

**多代理的优势**：
```python
# 多代理协作处理复杂任务
class ResearchAgent:     # 专精信息搜索
class AnalysisAgent:     # 专精数据分析
class WritingAgent:      # 专精内容创作
class QualityAgent:      # 专精质量控制

# 每个代理都有自己的专长和工具
# 通过状态共享实现无缝协作
```

- ✅ **专业化分工**：每个代理专注于自己最擅长的领域
- ✅ **状态共享**：信息在代理间透明传递
- ✅ **并行处理**：多个代理可以同时工作提高效率
- ✅ **模块化设计**：易于测试、维护和扩展

## 🤝 基础：第一个双代理协作

让我们从最简单的双代理协作开始，建立对多代理系统的基本理解。

### 场景：智能研究助手

**需求**：用户提出一个研究问题，系统自动搜索相关信息并生成总结报告。

**代理分工**：
- 🔍 **研究员代理**：负责搜索和收集相关信息
- 📝 **总结员代理**：负责分析信息并生成结构化总结

### 完整实现

```python
from langgraph.graph import StateGraph, END
from typing_extensions import TypedDict, NotRequired
from typing import List, Dict, Any
import json

# 1. 多代理协作状态设计
class ResearchState(TypedDict):
    # 用户输入
    research_query: str
    
    # 研究员代理的工作区
    search_keywords: NotRequired[List[str]]
    raw_research_data: NotRequired[List[Dict[str, str]]]
    research_summary: NotRequired[str]
    
    # 总结员代理的工作区
    structured_analysis: NotRequired[Dict[str, Any]]
    final_report: NotRequired[str]
    
    # 协作信息
    current_agent: NotRequired[str]
    completed_phases: NotRequired[List[str]]
    quality_score: NotRequired[float]

# 2. 研究员代理实现
def researcher_agent(state: ResearchState):
    """🔍 研究员代理：专精信息搜索和数据收集"""
    query = state["research_query"]
    
    print(f"🔍 研究员代理开始工作...")
    print(f"   研究主题: {query}")
    
    # 生成搜索关键词
    keywords = extract_keywords(query)
    print(f"   提取关键词: {keywords}")
    
    # 模拟搜索过程（实际项目中会调用真实搜索API）
    research_data = simulate_research(keywords)
    print(f"   搜索到 {len(research_data)} 条相关信息")
    
    # 初步整理搜索结果
    summary = create_research_summary(research_data)
    
    return {
        "search_keywords": keywords,
        "raw_research_data": research_data,
        "research_summary": summary,
        "current_agent": "researcher",
        "completed_phases": state.get("completed_phases", []) + ["research"]
    }

def extract_keywords(query: str) -> List[str]:
    """提取搜索关键词（简化实现）"""
    # 实际项目中可能使用NLP模型或AI来提取关键词
    common_words = {"的", "是", "在", "有", "和", "与", "如何", "什么", "为什么"}
    words = [word for word in query.split() if word not in common_words]
    return words[:5]  # 限制关键词数量

def simulate_research(keywords: List[str]) -> List[Dict[str, str]]:
    """模拟搜索过程"""
    # 在实际项目中，这里会调用真实的搜索API
    research_data = []
    for keyword in keywords:
        research_data.extend([
            {
                "title": f"关于{keyword}的最新研究进展",
                "content": f"根据最新研究，{keyword}在相关领域表现出了显著的发展趋势...",
                "source": f"学术期刊_{keyword}",
                "relevance": 0.9
            },
            {
                "title": f"{keyword}的实际应用案例",
                "content": f"在实际应用中，{keyword}已经被成功运用到多个项目中...",
                "source": f"行业报告_{keyword}",
                "relevance": 0.8
            }
        ])
    return research_data

def create_research_summary(data: List[Dict[str, str]]) -> str:
    """创建研究摘要"""
    if not data:
        return "未找到相关研究资料"
    
    high_relevance = [item for item in data if item.get("relevance", 0) > 0.8]
    summary = f"共搜索到 {len(data)} 条信息，其中 {len(high_relevance)} 条高相关度资料。"
    summary += f"主要来源包括：{', '.join(set(item['source'] for item in data[:3]))}"
    return summary

# 3. 总结员代理实现
def summarizer_agent(state: ResearchState):
    """📝 总结员代理：专精信息分析和报告生成"""
    research_data = state.get("raw_research_data", [])
    query = state["research_query"]
    
    print(f"📝 总结员代理开始工作...")
    print(f"   分析 {len(research_data)} 条研究数据")
    
    # 结构化分析
    analysis = perform_structured_analysis(research_data, query)
    print(f"   完成结构化分析")
    
    # 生成最终报告
    report = generate_final_report(query, analysis, research_data)
    print(f"   生成最终报告 ({len(report)} 字符)")
    
    # 质量评估
    quality = assess_report_quality(report, research_data)
    print(f"   质量评分: {quality:.2f}")
    
    return {
        "structured_analysis": analysis,
        "final_report": report,
        "quality_score": quality,
        "current_agent": "summarizer",
        "completed_phases": state.get("completed_phases", []) + ["analysis", "reporting"]
    }

def perform_structured_analysis(data: List[Dict[str, str]], query: str) -> Dict[str, Any]:
    """执行结构化分析"""
    analysis = {
        "total_sources": len(data),
        "high_relevance_count": len([item for item in data if item.get("relevance", 0) > 0.8]),
        "source_types": list(set(item.get("source", "").split("_")[0] for item in data)),
        "key_themes": extract_themes(data),
        "confidence_level": calculate_confidence(data)
    }
    return analysis

def extract_themes(data: List[Dict[str, str]]) -> List[str]:
    """提取关键主题"""
    # 简化的主题提取逻辑
    all_content = " ".join(item.get("content", "") for item in data)
    themes = ["技术发展", "实际应用", "发展趋势", "挑战与机遇"]
    return [theme for theme in themes if theme in all_content]

def calculate_confidence(data: List[Dict[str, str]]) -> float:
    """计算置信度"""
    if not data:
        return 0.0
    avg_relevance = sum(item.get("relevance", 0) for item in data) / len(data)
    source_diversity = len(set(item.get("source", "") for item in data)) / len(data)
    return (avg_relevance + source_diversity) / 2

def generate_final_report(query: str, analysis: Dict[str, Any], data: List[Dict[str, str]]) -> str:
    """生成最终报告"""
    report = f"""# 研究报告：{query}

## 执行摘要
本次研究共分析了 {analysis['total_sources']} 个信息源，其中 {analysis['high_relevance_count']} 个高相关度来源。
研究置信度为 {analysis['confidence_level']:.2f}。

## 主要发现
"""
    
    # 添加关键主题
    if analysis['key_themes']:
        report += "### 关键主题\n"
        for theme in analysis['key_themes']:
            report += f"- {theme}\n"
        report += "\n"
    
    # 添加详细内容
    report += "### 详细分析\n"
    for i, item in enumerate(data[:3], 1):  # 只展示前3个最相关的结果
        report += f"{i}. **{item.get('title', '无标题')}**\n"
        report += f"   来源：{item.get('source', '未知')}\n"
        report += f"   内容：{item.get('content', '无内容')[:100]}...\n\n"
    
    report += "## 结论\n"
    report += f"基于以上分析，针对"{query}"的研究显示了相关领域的重要进展和发展趋势。"
    
    return report

def assess_report_quality(report: str, data: List[Dict[str, str]]) -> float:
    """评估报告质量"""
    # 简单的质量评估逻辑
    length_score = min(1.0, len(report) / 1000)  # 长度评分
    structure_score = 1.0 if "## 执行摘要" in report and "## 主要发现" in report else 0.5
    data_usage_score = min(1.0, len(data) / 10)  # 数据使用评分
    
    return (length_score + structure_score + data_usage_score) / 3

# 4. 构建双代理协作图
def create_research_assistant():
    """创建智能研究助手"""
    workflow = StateGraph(ResearchState)
    
    # 添加代理节点
    workflow.add_node("researcher", researcher_agent)
    workflow.add_node("summarizer", summarizer_agent)
    
    # 定义协作流程：研究员 → 总结员
    workflow.set_entry_point("researcher")
    workflow.add_edge("researcher", "summarizer")
    workflow.add_edge("summarizer", END)
    
    return workflow.compile()

# 5. 测试双代理协作
if __name__ == "__main__":
    app = create_research_assistant()
    
    # 测试研究任务
    result = app.invoke({
        "research_query": "人工智能在医疗诊断中的应用前景"
    })
    
    print("\n" + "="*50)
    print("🎯 双代理协作结果")
    print("="*50)
    print(f"研究主题: {result['research_query']}")
    print(f"完成阶段: {result['completed_phases']}")
    print(f"质量评分: {result['quality_score']:.2f}")
    print(f"\n📊 研究数据概览:")
    print(f"- 搜索关键词: {result['search_keywords']}")
    print(f"- 数据来源数量: {len(result['raw_research_data'])}")
    print(f"- 结构化分析: {result['structured_analysis']}")
    
    print(f"\n📄 最终报告:")
    print(result['final_report'])
```

### 🔍 深入理解：协作的核心机制

**1. 状态共享**：
```python
# 研究员代理添加数据到共享状态
return {
    "raw_research_data": research_data,  # 其他代理可以使用这个数据
    "research_summary": summary
}

# 总结员代理读取研究员的工作结果
research_data = state.get("raw_research_data", [])  # 获取研究员的成果
```

**2. 工作区隔离**：
```python
class ResearchState(TypedDict):
    # 研究员的工作区
    search_keywords: NotRequired[List[str]]
    raw_research_data: NotRequired[List[Dict[str, str]]]
    
    # 总结员的工作区  
    structured_analysis: NotRequired[Dict[str, Any]]
    final_report: NotRequired[str]
```

**3. 协作进度跟踪**：
```python
"completed_phases": state.get("completed_phases", []) + ["research"]
```

## 🏭 进阶：专业化代理团队

现在让我们构建一个更复杂的多代理系统：**智能内容创作工作室**

### 团队组成

- 🔍 **研究员**：收集主题相关的背景信息和数据
- ✍️ **撰写员**：根据研究结果创作初稿内容
- ✏️ **编辑**：改进文章结构、语言和可读性
- 🔍 **质检员**：验证事实准确性和整体质量
- 🎨 **设计师**：负责配图和格式优化（工具集成示例）

### 协作流程设计

```
用户需求 → 研究员 → 撰写员 → 编辑 → 质检员 → 设计师 → 最终成品
           ↓        ↓        ↓       ↓        ↓
        收集信息   创作初稿   改进文本  质量验证   视觉优化
```

### 完整实现

```python
from enum import Enum
from typing import Union

class ContentPhase(str, Enum):
    RESEARCH = "research"
    WRITING = "writing" 
    EDITING = "editing"
    QUALITY_CHECK = "quality_check"
    DESIGN = "design"
    COMPLETED = "completed"

class ContentQuality(str, Enum):
    POOR = "poor"
    FAIR = "fair"
    GOOD = "good"
    EXCELLENT = "excellent"

class ContentStudioState(TypedDict):
    # 用户需求
    content_topic: str
    content_type: NotRequired[str]  # "article", "blog", "report"
    target_audience: NotRequired[str]
    word_count_target: NotRequired[int]
    
    # 研究员工作区
    research_keywords: NotRequired[List[str]]
    background_info: NotRequired[List[Dict[str, Any]]]
    research_confidence: NotRequired[float]
    
    # 撰写员工作区
    content_outline: NotRequired[List[str]]
    draft_content: NotRequired[str]
    writing_style: NotRequired[str]
    
    # 编辑工作区
    editing_feedback: NotRequired[List[str]]
    revised_content: NotRequired[str]
    readability_score: NotRequired[float]
    
    # 质检员工作区
    fact_check_results: NotRequired[List[Dict[str, Any]]]
    quality_assessment: NotRequired[ContentQuality]
    improvement_suggestions: NotRequired[List[str]]
    
    # 设计师工作区
    visual_elements: NotRequired[List[str]]
    formatted_content: NotRequired[str]
    design_assets: NotRequired[List[str]]
    
    # 流程控制
    current_phase: NotRequired[ContentPhase]
    completed_agents: NotRequired[List[str]]
    overall_progress: NotRequired[float]
    final_output: NotRequired[str]

# 研究员代理
def content_researcher(state: ContentStudioState):
    """🔍 内容研究员：收集主题相关信息"""
    topic = state["content_topic"]
    content_type = state.get("content_type", "article")
    
    print(f"🔍 研究员开始工作...")
    print(f"   主题: {topic}")
    print(f"   类型: {content_type}")
    
    # 生成研究关键词
    keywords = generate_research_keywords(topic, content_type)
    print(f"   关键词: {keywords}")
    
    # 收集背景信息
    background_info = collect_background_info(keywords)
    print(f"   收集到 {len(background_info)} 条背景信息")
    
    # 评估研究置信度
    confidence = assess_research_confidence(background_info)
    
    return {
        "research_keywords": keywords,
        "background_info": background_info,
        "research_confidence": confidence,
        "current_phase": ContentPhase.RESEARCH,
        "completed_agents": state.get("completed_agents", []) + ["researcher"],
        "overall_progress": 0.2
    }

def generate_research_keywords(topic: str, content_type: str) -> List[str]:
    """生成研究关键词"""
    base_keywords = topic.split()
    
    # 根据内容类型添加特定关键词
    type_keywords = {
        "article": ["分析", "趋势", "影响"],
        "blog": ["实践", "经验", "技巧"],
        "report": ["数据", "研究", "报告"]
    }
    
    return base_keywords + type_keywords.get(content_type, [])

def collect_background_info(keywords: List[str]) -> List[Dict[str, Any]]:
    """收集背景信息（模拟）"""
    info = []
    for keyword in keywords:
        info.extend([
            {
                "title": f"{keyword}的最新发展趋势",
                "content": f"关于{keyword}的最新研究表明...",
                "source": "行业报告",
                "credibility": 0.9,
                "relevance": 0.8
            },
            {
                "title": f"{keyword}的实际应用案例",
                "content": f"在实际应用中，{keyword}展现出...",
                "source": "案例研究",
                "credibility": 0.8,
                "relevance": 0.9
            }
        ])
    return info

def assess_research_confidence(info: List[Dict[str, Any]]) -> float:
    """评估研究置信度"""
    if not info:
        return 0.0
    
    avg_credibility = sum(item.get("credibility", 0) for item in info) / len(info)
    avg_relevance = sum(item.get("relevance", 0) for item in info) / len(info)
    
    return (avg_credibility + avg_relevance) / 2

# 撰写员代理
def content_writer(state: ContentStudioState):
    """✍️ 内容撰写员：创作高质量初稿"""
    topic = state["content_topic"]
    background_info = state.get("background_info", [])
    target_words = state.get("word_count_target", 1000)
    
    print(f"✍️ 撰写员开始工作...")
    print(f"   基于 {len(background_info)} 条研究信息")
    print(f"   目标字数: {target_words}")
    
    # 创建内容大纲
    outline = create_content_outline(topic, background_info)
    print(f"   大纲章节: {len(outline)}")
    
    # 撰写初稿
    draft = write_initial_draft(outline, background_info, target_words)
    print(f"   初稿完成: {len(draft)} 字符")
    
    # 确定写作风格
    style = determine_writing_style(topic, state.get("target_audience", "general"))
    
    return {
        "content_outline": outline,
        "draft_content": draft,
        "writing_style": style,
        "current_phase": ContentPhase.WRITING,
        "completed_agents": state.get("completed_agents", []) + ["writer"],
        "overall_progress": 0.4
    }

def create_content_outline(topic: str, info: List[Dict[str, Any]]) -> List[str]:
    """创建内容大纲"""
    # 基础大纲结构
    outline = [
        f"引言：{topic}的重要性",
        f"{topic}的现状分析",
        f"{topic}的发展趋势",
        f"{topic}的实际应用",
        f"结论与展望"
    ]
    
    # 根据研究信息调整大纲
    themes = set()
    for item in info:
        if "趋势" in item.get("title", ""):
            themes.add("发展趋势")
        if "案例" in item.get("title", ""):
            themes.add("实际应用")
        if "挑战" in item.get("title", ""):
            themes.add("挑战分析")
    
    return outline

def write_initial_draft(outline: List[str], info: List[Dict[str, Any]], target_words: int) -> str:
    """撰写初稿"""
    words_per_section = target_words // len(outline)
    
    draft = ""
    for section in outline:
        draft += f"\n## {section}\n\n"
        
        # 找到相关信息
        relevant_info = [item for item in info 
                        if any(keyword in item.get("title", "") for keyword in section.split())]
        
        if relevant_info:
            for item in relevant_info[:2]:  # 每个章节最多用2条信息
                draft += f"{item.get('content', '')} "
        else:
            draft += f"关于{section}的详细分析内容... "
        
        # 补充到目标字数
        current_length = len(draft.split())
        if current_length < words_per_section:
            draft += "这里需要更多的详细说明和分析内容。" * ((words_per_section - current_length) // 8)
        
        draft += "\n\n"
    
    return draft

def determine_writing_style(topic: str, audience: str) -> str:
    """确定写作风格"""
    style_map = {
        "general": "通俗易懂",
        "professional": "专业严谨", 
        "academic": "学术规范",
        "casual": "轻松活泼"
    }
    return style_map.get(audience, "通俗易懂")

# 编辑代理
def content_editor(state: ContentStudioState):
    """✏️ 内容编辑：改进文章质量"""
    draft = state.get("draft_content", "")
    style = state.get("writing_style", "通俗易懂")
    
    print(f"✏️ 编辑开始工作...")
    print(f"   原稿长度: {len(draft)} 字符")
    print(f"   目标风格: {style}")
    
    # 分析现有内容
    feedback = analyze_content_issues(draft)
    print(f"   发现 {len(feedback)} 个改进点")
    
    # 修订内容
    revised = revise_content(draft, feedback, style)
    print(f"   修订完成: {len(revised)} 字符")
    
    # 评估可读性
    readability = assess_readability(revised)
    print(f"   可读性评分: {readability:.2f}")
    
    return {
        "editing_feedback": feedback,
        "revised_content": revised,
        "readability_score": readability,
        "current_phase": ContentPhase.EDITING,
        "completed_agents": state.get("completed_agents", []) + ["editor"],
        "overall_progress": 0.6
    }

def analyze_content_issues(content: str) -> List[str]:
    """分析内容问题"""
    issues = []
    
    # 检查结构问题
    if content.count("##") < 3:
        issues.append("章节结构不够清晰，建议增加小标题")
    
    # 检查长度问题
    paragraphs = content.split("\n\n")
    long_paragraphs = [p for p in paragraphs if len(p) > 500]
    if long_paragraphs:
        issues.append(f"有 {len(long_paragraphs)} 个段落过长，建议分段")
    
    # 检查语言问题
    if content.count("。") < content.count("\n") * 2:
        issues.append("句子结构可以更加丰富多样")
    
    # 检查过渡问题
    if "另外" not in content and "此外" not in content and "因此" not in content:
        issues.append("段落间缺乏逻辑过渡词")
    
    return issues

def revise_content(content: str, feedback: List[str], style: str) -> str:
    """修订内容"""
    revised = content
    
    # 根据反馈进行修订
    for issue in feedback:
        if "章节结构" in issue:
            # 改进章节结构（简化实现）
            revised = revised.replace("。", "。\n\n", 1)  # 增加段落分隔
        
        if "段落过长" in issue:
            # 分割长段落
            paragraphs = revised.split("\n\n")
            new_paragraphs = []
            for p in paragraphs:
                if len(p) > 500:
                    # 简单分割
                    mid = len(p) // 2
                    new_paragraphs.extend([p[:mid], p[mid:]])
                else:
                    new_paragraphs.append(p)
            revised = "\n\n".join(new_paragraphs)
        
        if "过渡词" in issue:
            # 添加过渡词
            revised = revised.replace("## ", "## 此外，", 1)
    
    # 根据风格调整
    style_adjustments = {
        "专业严谨": lambda x: x.replace("很", "相当").replace("非常", "极其"),
        "通俗易懂": lambda x: x.replace("因此", "所以").replace("此外", "另外"),
        "学术规范": lambda x: x.replace("我们", "本研究").replace("觉得", "认为")
    }
    
    if style in style_adjustments:
        revised = style_adjustments[style](revised)
    
    return revised

def assess_readability(content: str) -> float:
    """评估可读性"""
    # 简化的可读性评估
    sentences = content.count("。")
    words = len(content.split())
    paragraphs = content.count("\n\n")
    
    if sentences == 0 or paragraphs == 0:
        return 0.0
    
    avg_sentence_length = words / sentences
    avg_paragraph_length = sentences / paragraphs
    
    # 理想的句子长度是15-25字，段落长度是3-5句
    sentence_score = max(0, 1 - abs(avg_sentence_length - 20) / 20)
    paragraph_score = max(0, 1 - abs(avg_paragraph_length - 4) / 4)
    
    return (sentence_score + paragraph_score) / 2

# 质检员代理
def quality_checker(state: ContentStudioState):
    """🔍 质量检查员：验证内容质量"""
    content = state.get("revised_content", "")
    original_topic = state["content_topic"]
    background_info = state.get("background_info", [])
    
    print(f"🔍 质检员开始工作...")
    print(f"   检查内容长度: {len(content)} 字符")
    
    # 事实检查
    fact_results = perform_fact_check(content, background_info)
    print(f"   事实检查: {len(fact_results)} 个检查点")
    
    # 质量评估
    quality = assess_overall_quality(content, original_topic)
    print(f"   整体质量: {quality.value}")
    
    # 改进建议
    suggestions = generate_improvement_suggestions(content, fact_results, quality)
    print(f"   改进建议: {len(suggestions)} 条")
    
    return {
        "fact_check_results": fact_results,
        "quality_assessment": quality,
        "improvement_suggestions": suggestions,
        "current_phase": ContentPhase.QUALITY_CHECK,
        "completed_agents": state.get("completed_agents", []) + ["quality_checker"],
        "overall_progress": 0.8
    }

def perform_fact_check(content: str, background_info: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """执行事实检查"""
    results = []
    
    # 检查关键声明
    claims = extract_claims(content)
    
    for claim in claims:
        # 在背景信息中验证
        supporting_info = [info for info in background_info 
                          if any(word in info.get("content", "") for word in claim.split()[:3])]
        
        if supporting_info:
            confidence = sum(info.get("credibility", 0) for info in supporting_info) / len(supporting_info)
            results.append({
                "claim": claim,
                "verified": confidence > 0.7,
                "confidence": confidence,
                "sources": len(supporting_info)
            })
        else:
            results.append({
                "claim": claim,
                "verified": False,
                "confidence": 0.0,
                "sources": 0
            })
    
    return results

def extract_claims(content: str) -> List[str]:
    """提取关键声明"""
    # 简化的声明提取
    sentences = [s.strip() for s in content.split("。") if s.strip()]
    
    # 过滤出可能包含事实声明的句子
    claim_indicators = ["研究表明", "数据显示", "根据", "调查发现", "专家认为"]
    claims = []
    
    for sentence in sentences:
        if any(indicator in sentence for indicator in claim_indicators):
            claims.append(sentence)
    
    return claims[:5]  # 最多检查5个关键声明

def assess_overall_quality(content: str, topic: str) -> ContentQuality:
    """评估整体质量"""
    score = 0
    
    # 内容长度评分
    if len(content) > 1000:
        score += 25
    elif len(content) > 500:
        score += 15
    
    # 结构评分
    if content.count("##") >= 3:
        score += 25
    
    # 主题相关性评分
    topic_words = topic.split()
    topic_mentions = sum(content.lower().count(word.lower()) for word in topic_words)
    if topic_mentions >= 5:
        score += 25
    elif topic_mentions >= 3:
        score += 15
    
    # 语言质量评分
    if len(content.split("。")) > 10:  # 有足够的句子
        score += 25
    
    # 转换为质量等级
    if score >= 80:
        return ContentQuality.EXCELLENT
    elif score >= 60:
        return ContentQuality.GOOD
    elif score >= 40:
        return ContentQuality.FAIR
    else:
        return ContentQuality.POOR

def generate_improvement_suggestions(content: str, fact_results: List[Dict[str, Any]], 
                                   quality: ContentQuality) -> List[str]:
    """生成改进建议"""
    suggestions = []
    
    # 基于事实检查的建议
    unverified_claims = [r for r in fact_results if not r["verified"]]
    if unverified_claims:
        suggestions.append(f"有 {len(unverified_claims)} 个声明缺乏可靠来源支持，建议补充引用")
    
    # 基于质量评估的建议
    if quality == ContentQuality.POOR:
        suggestions.extend([
            "内容长度不足，建议扩充详细信息",
            "结构不够清晰，建议增加章节标题",
            "主题相关性较低，建议聚焦核心话题"
        ])
    elif quality == ContentQuality.FAIR:
        suggestions.extend([
            "可以增加更多具体案例和数据支持",
            "建议改进段落间的逻辑连接"
        ])
    elif quality == ContentQuality.GOOD:
        suggestions.append("整体质量良好，可以考虑增加图表或视觉元素")
    
    return suggestions

# 设计师代理（工具集成示例）
def content_designer(state: ContentStudioState):
    """🎨 内容设计师：视觉优化和格式设计"""
    content = state.get("revised_content", "")
    topic = state["content_topic"]
    
    print(f"🎨 设计师开始工作...")
    print(f"   优化内容长度: {len(content)} 字符")
    
    # 识别视觉需求
    visual_needs = identify_visual_needs(content)
    print(f"   识别视觉需求: {visual_needs}")
    
    # 生成视觉元素（模拟工具调用）
    visual_elements = generate_visual_elements(visual_needs, topic)
    print(f"   生成 {len(visual_elements)} 个视觉元素")
    
    # 格式化内容
    formatted = format_content_with_visuals(content, visual_elements)
    print(f"   格式化完成")
    
    return {
        "visual_elements": visual_needs,
        "formatted_content": formatted,
        "design_assets": visual_elements,
        "current_phase": ContentPhase.DESIGN,
        "completed_agents": state.get("completed_agents", []) + ["designer"],
        "overall_progress": 1.0,
        "final_output": formatted
    }

def identify_visual_needs(content: str) -> List[str]:
    """识别视觉需求"""
    needs = []
    
    # 检查是否需要图表
    if any(word in content for word in ["数据", "统计", "比例", "增长"]):
        needs.append("数据图表")
    
    # 检查是否需要流程图
    if any(word in content for word in ["步骤", "流程", "过程", "阶段"]):
        needs.append("流程图")
    
    # 检查是否需要配图
    if any(word in content for word in ["应用", "案例", "实例"]):
        needs.append("示例图片")
    
    # 基础需求
    needs.append("标题设计")
    needs.append("排版优化")
    
    return needs

def generate_visual_elements(needs: List[str], topic: str) -> List[str]:
    """生成视觉元素（模拟工具调用）"""
    elements = []
    
    for need in needs:
        if need == "数据图表":
            elements.append(f"chart_{topic}_data.png")
        elif need == "流程图":
            elements.append(f"flowchart_{topic}_process.png")
        elif need == "示例图片":
            elements.append(f"example_{topic}_case.jpg")
        elif need == "标题设计":
            elements.append(f"title_{topic}_header.png")
        elif need == "排版优化":
            elements.append("layout_template.css")
    
    return elements

def format_content_with_visuals(content: str, visual_elements: List[str]) -> str:
    """格式化内容并插入视觉元素"""
    formatted = content
    
    # 在每个主要章节后插入相关图片
    sections = formatted.split("## ")
    enhanced_sections = []
    
    for i, section in enumerate(sections):
        enhanced_sections.append(section)
        
        # 为每个章节添加合适的视觉元素
        if i < len(visual_elements):
            visual_element = visual_elements[i]
            enhanced_sections.append(f"\n\n![相关图片]({visual_element})\n\n")
    
    # 添加样式和布局
    formatted = "## ".join(enhanced_sections)
    formatted = f"""
<style>
body {{ font-family: Arial, sans-serif; line-height: 1.6; }}
h2 {{ color: #2c3e50; border-bottom: 2px solid #3498db; }}
img {{ max-width: 100%; height: auto; margin: 20px 0; }}
</style>

{formatted}

<footer>
<p><em>本内容由AI多代理协作系统生成</em></p>
</footer>
"""
    
    return formatted

# 构建完整的内容创作工作室
def create_content_studio():
    """创建智能内容创作工作室"""
    workflow = StateGraph(ContentStudioState)
    
    # 添加所有代理
    workflow.add_node("researcher", content_researcher)
    workflow.add_node("writer", content_writer)
    workflow.add_node("editor", content_editor)
    workflow.add_node("quality_checker", quality_checker)
    workflow.add_node("designer", content_designer)
    
    # 定义流水线协作流程
    workflow.set_entry_point("researcher")
    workflow.add_edge("researcher", "writer")
    workflow.add_edge("writer", "editor")
    workflow.add_edge("editor", "quality_checker")
    workflow.add_edge("quality_checker", "designer")
    workflow.add_edge("designer", END)
    
    return workflow.compile()

# 测试完整的多代理协作系统
if __name__ == "__main__":
    app = create_content_studio()
    
    # 测试内容创作任务
    result = app.invoke({
        "content_topic": "区块链技术在供应链管理中的应用",
        "content_type": "article",
        "target_audience": "professional",
        "word_count_target": 1500
    })
    
    print("\n" + "="*60)
    print("🎯 多代理内容创作工作室结果")
    print("="*60)
    print(f"主题: {result['content_topic']}")
    print(f"完成代理: {result['completed_agents']}")
    print(f"整体进度: {result['overall_progress']*100}%")
    print(f"质量评估: {result['quality_assessment']}")
    
    print(f"\n📊 各代理工作成果:")
    print(f"🔍 研究关键词: {result['research_keywords']}")
    print(f"✍️ 内容大纲: {result['content_outline']}")
    print(f"✏️ 编辑反馈: {result['editing_feedback']}")
    print(f"🔍 质检建议: {result['improvement_suggestions']}")
    print(f"🎨 视觉元素: {result['visual_elements']}")
    
    print(f"\n📄 最终成品预览:")
    print(result['final_output'][:500] + "..." if len(result['final_output']) > 500 else result['final_output'])
```

## 🛠️ 工具集成：扩展代理能力

工具集成是多代理系统的重要组成部分，它让代理能够调用外部服务和工具来扩展自己的能力。

### 工具系统架构

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

# 工具基础接口
class Tool(ABC):
    """工具基础类"""
    
    @property
    @abstractmethod
    def name(self) -> str:
        """工具名称"""
        pass
    
    @property
    @abstractmethod 
    def description(self) -> str:
        """工具描述"""
        pass
    
    @abstractmethod
    def execute(self, **kwargs) -> Dict[str, Any]:
        """执行工具"""
        pass

# 搜索工具实现
class WebSearchTool(Tool):
    """网络搜索工具"""
    
    @property
    def name(self) -> str:
        return "web_search"
    
    @property
    def description(self) -> str:
        return "搜索互联网获取最新信息"
    
    def execute(self, query: str, max_results: int = 5) -> Dict[str, Any]:
        """执行搜索（模拟实现）"""
        # 实际实现中会调用真实的搜索API
        print(f"🔍 搜索: {query}")
        
        # 模拟搜索结果
        results = [
            {
                "title": f"关于{query}的最新研究",
                "url": f"https://example.com/research/{query}",
                "snippet": f"最新研究表明，{query}在相关领域显示出重要进展...",
                "relevance": 0.9
            },
            {
                "title": f"{query}的实际应用案例",
                "url": f"https://example.com/cases/{query}",
                "snippet": f"在实际应用中，{query}已经被成功运用到...",
                "relevance": 0.8
            }
        ][:max_results]
        
        return {
            "success": True,
            "results": results,
            "total_found": len(results),
            "query": query
        }

# 数据分析工具
class DataAnalysisTool(Tool):
    """数据分析工具"""
    
    @property
    def name(self) -> str:
        return "data_analysis"
    
    @property
    def description(self) -> str:
        return "分析数据并生成图表"
    
    def execute(self, data: List[Dict[str, Any]], analysis_type: str = "summary") -> Dict[str, Any]:
        """执行数据分析"""
        print(f"📊 分析数据: {len(data)} 条记录, 类型: {analysis_type}")
        
        if analysis_type == "summary":
            return self._generate_summary(data)
        elif analysis_type == "trend":
            return self._analyze_trend(data)
        else:
            return {"success": False, "error": "不支持的分析类型"}
    
    def _generate_summary(self, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """生成数据摘要"""
        return {
            "success": True,
            "summary": {
                "total_records": len(data),
                "avg_relevance": sum(item.get("relevance", 0) for item in data) / len(data) if data else 0,
                "top_sources": list(set(item.get("source", "unknown") for item in data))[:3]
            },
            "chart_url": "data_summary_chart.png"
        }
    
    def _analyze_trend(self, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """分析趋势"""
        return {
            "success": True,
            "trend": {
                "direction": "上升",
                "confidence": 0.85,
                "key_factors": ["技术进步", "市场需求", "政策支持"]
            },
            "chart_url": "trend_analysis_chart.png"
        }

# 图片生成工具
class ImageGenerationTool(Tool):
    """图片生成工具"""
    
    @property
    def name(self) -> str:
        return "image_generation"
    
    @property
    def description(self) -> str:
        return "根据描述生成图片"
    
    def execute(self, description: str, style: str = "realistic") -> Dict[str, Any]:
        """生成图片"""
        print(f"🎨 生成图片: {description}, 风格: {style}")
        
        # 模拟图片生成
        filename = f"generated_{hash(description) % 10000}.png"
        
        return {
            "success": True,
            "image_url": filename,
            "description": description,
            "style": style,
            "dimensions": "1024x768"
        }

# 工具管理器
class ToolManager:
    """工具管理器"""
    
    def __init__(self):
        self.tools: Dict[str, Tool] = {}
    
    def register_tool(self, tool: Tool):
        """注册工具"""
        self.tools[tool.name] = tool
        print(f"✅ 注册工具: {tool.name}")
    
    def get_tool(self, name: str) -> Optional[Tool]:
        """获取工具"""
        return self.tools.get(name)
    
    def list_tools(self) -> List[str]:
        """列出所有工具"""
        return list(self.tools.keys())
    
    def execute_tool(self, tool_name: str, **kwargs) -> Dict[str, Any]:
        """执行工具"""
        tool = self.get_tool(tool_name)
        if not tool:
            return {"success": False, "error": f"工具 {tool_name} 不存在"}
        
        try:
            return tool.execute(**kwargs)
        except Exception as e:
            return {"success": False, "error": str(e)}

# 带工具集成的代理状态
class ToolIntegratedState(TypedDict):
    user_query: str
    search_results: NotRequired[List[Dict[str, Any]]]
    analysis_results: NotRequired[Dict[str, Any]]
    generated_images: NotRequired[List[str]]
    tool_usage_log: NotRequired[List[Dict[str, Any]]]
    final_response: NotRequired[str]

# 带工具的搜索代理
def tool_enhanced_researcher(state: ToolIntegratedState):
    """🔍 工具增强的研究代理"""
    query = state["user_query"]
    
    print(f"🔍 启动工具增强研究代理...")
    
    # 初始化工具管理器
    tool_manager = ToolManager()
    tool_manager.register_tool(WebSearchTool())
    tool_manager.register_tool(DataAnalysisTool())
    
    # 执行搜索
    search_result = tool_manager.execute_tool("web_search", query=query, max_results=3)
    
    tool_log = [{
        "tool": "web_search",
        "input": {"query": query},
        "output": search_result,
        "timestamp": "2024-01-01T10:00:00"
    }]
    
    if search_result["success"]:
        # 分析搜索结果
        analysis_result = tool_manager.execute_tool(
            "data_analysis", 
            data=search_result["results"], 
            analysis_type="summary"
        )
        
        tool_log.append({
            "tool": "data_analysis", 
            "input": {"data": search_result["results"]},
            "output": analysis_result,
            "timestamp": "2024-01-01T10:01:00"
        })
        
        return {
            "search_results": search_result["results"],
            "analysis_results": analysis_result if analysis_result["success"] else None,
            "tool_usage_log": tool_log
        }
    else:
        return {
            "search_results": [],
            "tool_usage_log": tool_log,
            "error": "搜索失败"
        }

# 带工具的内容创作代理
def tool_enhanced_creator(state: ToolIntegratedState):
    """✍️ 工具增强的内容创作代理"""
    search_results = state.get("search_results", [])
    analysis = state.get("analysis_results", {})
    
    print(f"✍️ 启动工具增强创作代理...")
    
    # 初始化工具
    tool_manager = ToolManager()
    tool_manager.register_tool(ImageGenerationTool())
    
    # 生成内容
    content = create_enhanced_content(search_results, analysis)
    
    # 生成配图
    images = []
    if search_results:
        for result in search_results[:2]:  # 为前两个结果生成配图
            img_result = tool_manager.execute_tool(
                "image_generation",
                description=f"插图: {result['title']}",
                style="professional"
            )
            if img_result["success"]:
                images.append(img_result["image_url"])
    
    tool_log = state.get("tool_usage_log", [])
    tool_log.append({
        "tool": "image_generation",
        "input": {"count": len(images)},
        "output": {"generated_images": images},
        "timestamp": "2024-01-01T10:02:00"
    })
    
    return {
        "generated_images": images,
        "final_response": content,
        "tool_usage_log": tool_log
    }

def create_enhanced_content(search_results: List[Dict[str, Any]], 
                          analysis: Dict[str, Any]) -> str:
    """创建增强内容"""
    content = "# 研究报告\n\n"
    
    if analysis and "summary" in analysis:
        summary = analysis["summary"]
        content += f"## 数据概览\n"
        content += f"- 总计分析了 {summary['total_records']} 个信息源\n"
        content += f"- 平均相关度: {summary['avg_relevance']:.2f}\n"
        content += f"- 主要来源: {', '.join(summary['top_sources'])}\n\n"
    
    content += "## 详细发现\n\n"
    for i, result in enumerate(search_results, 1):
        content += f"### {i}. {result['title']}\n"
        content += f"{result['snippet']}\n"
        content += f"*来源: {result['url']}*\n\n"
    
    return content

# 创建工具集成的工作流
def create_tool_integrated_workflow():
    """创建工具集成工作流"""
    workflow = StateGraph(ToolIntegratedState)
    
    workflow.add_node("researcher", tool_enhanced_researcher)
    workflow.add_node("creator", tool_enhanced_creator)
    
    workflow.set_entry_point("researcher")
    workflow.add_edge("researcher", "creator")
    workflow.add_edge("creator", END)
    
    return workflow.compile()

# 测试工具集成
if __name__ == "__main__":
    app = create_tool_integrated_workflow()
    
    result = app.invoke({
        "user_query": "人工智能在教育领域的最新应用"
    })
    
    print("\n" + "="*50)
    print("🛠️ 工具集成测试结果")
    print("="*50)
    print(f"查询: {result['user_query']}")
    print(f"搜索结果: {len(result.get('search_results', []))} 条")
    print(f"生成图片: {len(result.get('generated_images', []))} 张")
    print(f"工具使用记录: {len(result.get('tool_usage_log', []))} 次")
    
    print(f"\n🛠️ 工具使用详情:")
    for log in result.get('tool_usage_log', []):
        print(f"- {log['tool']}: {log.get('timestamp', 'N/A')}")
    
    print(f"\n📄 最终内容:")
    print(result.get('final_response', '无内容'))
```

## 🔄 高级协作模式

### 并行协作模式

有时候我们需要多个代理同时工作以提高效率：

```python
class ParallelResearchState(TypedDict):
    research_topic: str
    
    # 并行研究结果
    tech_research: NotRequired[Dict[str, Any]]
    market_research: NotRequired[Dict[str, Any]]
    academic_research: NotRequired[Dict[str, Any]]
    
    # 合并结果
    combined_insights: NotRequired[str]
    final_report: NotRequired[str]

def tech_researcher(state: ParallelResearchState):
    """🔧 技术研究员"""
    topic = state["research_topic"]
    print(f"🔧 技术研究员分析: {topic}")
    
    # 模拟技术角度的研究
    tech_insights = {
        "technical_feasibility": 0.8,
        "implementation_complexity": "中等",
        "required_technologies": ["AI", "云计算", "大数据"],
        "technical_challenges": ["数据安全", "系统集成", "性能优化"]
    }
    
    return {"tech_research": tech_insights}

def market_researcher(state: ParallelResearchState):
    """📈 市场研究员"""
    topic = state["research_topic"]
    print(f"📈 市场研究员分析: {topic}")
    
    # 模拟市场角度的研究
    market_insights = {
        "market_size": "100亿美元",
        "growth_rate": "15%年增长",
        "key_players": ["公司A", "公司B", "公司C"],
        "market_trends": ["自动化", "个性化", "移动化"]
    }
    
    return {"market_research": market_insights}

def academic_researcher(state: ParallelResearchState):
    """🎓 学术研究员"""
    topic = state["research_topic"]
    print(f"🎓 学术研究员分析: {topic}")
    
    # 模拟学术角度的研究
    academic_insights = {
        "research_papers": 150,
        "key_theories": ["理论A", "理论B"],
        "research_gaps": ["缺乏长期研究", "样本规模有限"],
        "future_directions": ["跨学科研究", "实证研究"]
    }
    
    return {"academic_research": academic_insights}

def insight_synthesizer(state: ParallelResearchState):
    """🧠 洞察综合员"""
    tech = state.get("tech_research", {})
    market = state.get("market_research", {})
    academic = state.get("academic_research", {})
    
    print(f"🧠 综合多维度研究结果...")
    
    # 综合三个维度的研究结果
    combined = f"""
# 综合研究洞察

## 技术维度
- 技术可行性: {tech.get('technical_feasibility', 'N/A')}
- 实现复杂度: {tech.get('implementation_complexity', 'N/A')}
- 关键技术: {', '.join(tech.get('required_technologies', []))}

## 市场维度  
- 市场规模: {market.get('market_size', 'N/A')}
- 增长率: {market.get('growth_rate', 'N/A')}
- 市场趋势: {', '.join(market.get('market_trends', []))}

## 学术维度
- 相关论文: {academic.get('research_papers', 'N/A')} 篇
- 核心理论: {', '.join(academic.get('key_theories', []))}
- 研究方向: {', '.join(academic.get('future_directions', []))}

## 综合建议
基于技术、市场和学术三个维度的分析，建议采用渐进式发展策略...
"""
    
    return {
        "combined_insights": combined,
        "final_report": combined
    }

def create_parallel_research_workflow():
    """创建并行研究工作流"""
    workflow = StateGraph(ParallelResearchState)
    
    # 添加并行研究节点
    workflow.add_node("tech_researcher", tech_researcher)
    workflow.add_node("market_researcher", market_researcher)
    workflow.add_node("academic_researcher", academic_researcher)
    workflow.add_node("synthesizer", insight_synthesizer)
    
    # 设置并行执行
    workflow.set_entry_point("tech_researcher")
    workflow.set_entry_point("market_researcher")
    workflow.set_entry_point("academic_researcher")
    
    # 并行结果汇总
    workflow.add_edge("tech_researcher", "synthesizer")
    workflow.add_edge("market_researcher", "synthesizer") 
    workflow.add_edge("academic_researcher", "synthesizer")
    workflow.add_edge("synthesizer", END)
    
    return workflow.compile()
```

### 反馈循环协作模式

有些任务需要代理之间相互反馈和迭代改进：

```python
class FeedbackLoopState(TypedDict):
    original_content: str
    
    # 迭代版本
    current_version: NotRequired[str]
    iteration_count: NotRequired[int]
    
    # 编辑反馈
    editor_feedback: NotRequired[List[str]]
    writer_revisions: NotRequired[List[str]]
    
    # 质量跟踪
    quality_scores: NotRequired[List[float]]
    improvement_threshold: NotRequired[float]
    
    # 最终结果
    final_version: NotRequired[str]
    improvement_log: NotRequired[List[str]]

def content_writer_v2(state: FeedbackLoopState):
    """✍️ 内容写作员（支持迭代）"""
    current_content = state.get("current_version", state["original_content"])
    feedback = state.get("editor_feedback", [])
    iteration = state.get("iteration_count", 0)
    
    print(f"✍️ 写作员开始第 {iteration + 1} 次迭代...")
    
    if feedback:
        print(f"   处理 {len(feedback)} 条编辑反馈")
        # 根据反馈改进内容
        revised_content = apply_feedback(current_content, feedback)
    else:
        # 首次创作
        revised_content = create_initial_content(state["original_content"])
    
    revisions = state.get("writer_revisions", [])
    revisions.append(f"第{iteration + 1}次迭代：应用编辑反馈，改进内容质量")
    
    return {
        "current_version": revised_content,
        "iteration_count": iteration + 1,
        "writer_revisions": revisions
    }

def content_editor_v2(state: FeedbackLoopState):
    """✏️ 内容编辑（支持迭代）"""
    content = state.get("current_version", "")
    iteration = state.get("iteration_count", 0)
    
    print(f"✏️ 编辑开始第 {iteration} 次审核...")
    
    # 分析内容质量
    quality_score = evaluate_content_quality(content)
    feedback = generate_editing_feedback(content, iteration)
    
    quality_scores = state.get("quality_scores", [])
    quality_scores.append(quality_score)
    
    print(f"   质量评分: {quality_score:.2f}")
    print(f"   反馈条数: {len(feedback)}")
    
    return {
        "editor_feedback": feedback,
        "quality_scores": quality_scores
    }

def evaluate_content_quality(content: str) -> float:
    """评估内容质量"""
    # 基础质量指标
    length_score = min(1.0, len(content) / 1000)
    structure_score = 1.0 if content.count("\n\n") >= 3 else 0.5
    
    # 语言质量（简化评估）
    sentences = content.count("。")
    words = len(content.split())
    language_score = 0.8 if sentences > 5 and words > 100 else 0.4
    
    return (length_score + structure_score + language_score) / 3

def generate_editing_feedback(content: str, iteration: int) -> List[str]:
    """生成编辑反馈"""
    feedback = []
    
    # 不同迭代关注不同方面
    if iteration == 1:
        # 第一次迭代关注结构
        if content.count("##") < 3:
            feedback.append("增加章节标题，改善文章结构")
        if len(content.split("\n\n")) < 5:
            feedback.append("增加段落分隔，提高可读性")
    
    elif iteration == 2:
        # 第二次迭代关注内容
        if "例如" not in content and "比如" not in content:
            feedback.append("添加具体例子和案例")
        if "因此" not in content and "所以" not in content:
            feedback.append("加强逻辑连接和论证")
    
    elif iteration >= 3:
        # 后续迭代关注细节
        if content.count("，") > content.count("。") * 2:
            feedback.append("简化句子结构，提高表达清晰度")
        feedback.append("最终润色，检查语法和用词")
    
    return feedback

def apply_feedback(content: str, feedback: List[str]) -> str:
    """应用编辑反馈"""
    revised = content
    
    for item in feedback:
        if "章节标题" in item:
            # 添加章节标题
            if "## " not in revised:
                parts = revised.split("\n\n")
                if len(parts) >= 3:
                    parts[0] = "## 引言\n\n" + parts[0]
                    parts[len(parts)//2] = "## 主要内容\n\n" + parts[len(parts)//2]
                    parts[-1] = "## 结论\n\n" + parts[-1]
                    revised = "\n\n".join(parts)
        
        elif "段落分隔" in item:
            # 增加段落分隔
            revised = revised.replace("。", "。\n\n", 2)
        
        elif "具体例子" in item:
            # 添加例子
            revised += "\n\n例如，在实际应用中我们可以看到相关的成功案例和实践经验。"
        
        elif "逻辑连接" in item:
            # 加强逻辑连接
            revised = revised.replace("。\n\n", "。因此，", 1)
            revised = revised.replace("。\n\n", "。此外，", 1)
    
    return revised

def create_initial_content(topic: str) -> str:
    """创建初始内容"""
    return f"""
{topic}是一个重要的研究领域。

在当前的发展环境下，{topic}显示出了重要的应用价值和发展前景。

相关研究表明，{topic}在多个方面都有显著的进展。

通过深入分析，我们可以看到{topic}的重要意义。
"""

def should_continue_iteration(state: FeedbackLoopState):
    """判断是否继续迭代"""
    iteration = state.get("iteration_count", 0)
    quality_scores = state.get("quality_scores", [])
    threshold = state.get("improvement_threshold", 0.8)
    
    # 最多迭代4次
    if iteration >= 4:
        return False
    
    # 质量达标则停止
    if quality_scores and quality_scores[-1] >= threshold:
        return False
    
    # 质量没有明显改善则停止
    if len(quality_scores) >= 2:
        improvement = quality_scores[-1] - quality_scores[-2]
        if improvement < 0.05:
            return False
    
    return True

def finalize_content(state: FeedbackLoopState):
    """最终确定内容"""
    final_content = state.get("current_version", "")
    quality_scores = state.get("quality_scores", [])
    
    improvement_log = []
    if quality_scores:
        initial_quality = quality_scores[0] if len(quality_scores) > 0 else 0
        final_quality = quality_scores[-1]
        improvement = final_quality - initial_quality
        
        improvement_log.append(f"初始质量: {initial_quality:.2f}")
        improvement_log.append(f"最终质量: {final_quality:.2f}")
        improvement_log.append(f"质量提升: {improvement:.2f}")
        improvement_log.append(f"迭代次数: {len(quality_scores)}")
    
    return {
        "final_version": final_content,
        "improvement_log": improvement_log
    }

def create_feedback_loop_workflow():
    """创建反馈循环工作流"""
    workflow = StateGraph(FeedbackLoopState)
    
    workflow.add_node("writer", content_writer_v2)
    workflow.add_node("editor", content_editor_v2)
    workflow.add_node("finalizer", finalize_content)
    
    # 设置循环流程
    workflow.set_entry_point("writer")
    workflow.add_edge("writer", "editor")
    
    # 条件循环：根据质量决定是否继续
    workflow.add_conditional_edges(
        "editor",
        should_continue_iteration,
        {
            True: "writer",    # 继续迭代
            False: "finalizer" # 结束迭代
        }
    )
    
    workflow.add_edge("finalizer", END)
    
    return workflow.compile()

# 测试反馈循环
if __name__ == "__main__":
    app = create_feedback_loop_workflow()
    
    result = app.invoke({
        "original_content": "人工智能的发展趋势",
        "improvement_threshold": 0.75
    })
    
    print("\n" + "="*50)
    print("🔄 反馈循环协作结果")
    print("="*50)
    print(f"迭代次数: {result['iteration_count']}")
    print(f"质量变化: {result['quality_scores']}")
    print(f"改进记录: {result['improvement_log']}")
    
    print(f"\n📄 最终内容:")
    print(result['final_version'])
```

## 🛡️ 系统容错与恢复

多代理系统需要强大的容错机制来处理各种异常情况：

```python
class RobustAgentState(TypedDict):
    task_description: str
    
    # 执行状态
    current_agent: NotRequired[str]
    completed_agents: NotRequired[List[str]]
    failed_agents: NotRequired[List[str]]
    
    # 结果存储
    agent_results: NotRequired[Dict[str, Any]]
    
    # 错误处理
    errors: NotRequired[List[Dict[str, Any]]]
    retry_count: NotRequired[Dict[str, int]]
    fallback_mode: NotRequired[bool]
    
    # 最终输出
    final_result: NotRequired[str]
    execution_summary: NotRequired[Dict[str, Any]]

class AgentError(Exception):
    """代理执行错误"""
    def __init__(self, agent_name: str, error_type: str, message: str):
        self.agent_name = agent_name
        self.error_type = error_type
        self.message = message
        super().__init__(f"{agent_name} {error_type}: {message}")

def resilient_researcher(state: RobustAgentState):
    """🔍 具有容错能力的研究代理"""
    task = state["task_description"]
    retry_count = state.get("retry_count", {}).get("researcher", 0)
    
    print(f"🔍 研究代理开始工作 (尝试 {retry_count + 1}/3)...")
    
    try:
        # 模拟可能失败的操作
        if retry_count == 0:
            # 第一次尝试：模拟网络错误
            raise AgentError("researcher", "NetworkError", "网络连接超时")
        elif retry_count == 1:
            # 第二次尝试：模拟API限制
            raise AgentError("researcher", "APIError", "API调用频率限制")
        else:
            # 第三次尝试：成功
            research_data = {"findings": f"关于{task}的研究结果", "confidence": 0.8}
            
            # 记录成功结果
            agent_results = state.get("agent_results", {})
            agent_results["researcher"] = research_data
            
            completed = state.get("completed_agents", [])
            completed.append("researcher")
            
            return {
                "agent_results": agent_results,
                "completed_agents": completed,
                "current_agent": "researcher"
            }
    
    except AgentError as e:
        print(f"❌ {e}")
        
        # 记录错误
        errors = state.get("errors", [])
        errors.append({
            "agent": e.agent_name,
            "type": e.error_type,
            "message": e.message,
            "retry_count": retry_count,
            "timestamp": "2024-01-01T10:00:00"
        })
        
        # 更新重试计数
        retry_counts = state.get("retry_count", {})
        retry_counts["researcher"] = retry_count + 1
        
        # 检查是否达到最大重试次数
        if retry_count >= 2:
            failed = state.get("failed_agents", [])
            failed.append("researcher")
            
            return {
                "errors": errors,
                "retry_count": retry_counts,
                "failed_agents": failed,
                "fallback_mode": True
            }
        else:
            return {
                "errors": errors,
                "retry_count": retry_counts
            }

def resilient_analyzer(state: RobustAgentState):
    """📊 具有容错能力的分析代理"""
    agent_results = state.get("agent_results", {})
    fallback_mode = state.get("fallback_mode", False)
    
    print(f"📊 分析代理开始工作...")
    
    if fallback_mode:
        print("⚠️ 进入降级模式：使用简化分析")
        # 降级处理：使用简化的分析逻辑
        analysis = {
            "summary": "基于可用信息的简化分析",
            "confidence": 0.5,
            "mode": "fallback"
        }
    else:
        # 正常处理
        research_data = agent_results.get("researcher", {})
        analysis = {
            "summary": f"深度分析：{research_data.get('findings', '无数据')}",
            "confidence": research_data.get("confidence", 0) * 0.9,
            "mode": "normal"
        }
    
    # 更新结果
    agent_results = state.get("agent_results", {})
    agent_results["analyzer"] = analysis
    
    completed = state.get("completed_agents", [])
    completed.append("analyzer")
    
    return {
        "agent_results": agent_results,
        "completed_agents": completed,
        "current_agent": "analyzer"
    }

def error_recovery_router(state: RobustAgentState):
    """🔧 错误恢复路由器"""
    errors = state.get("errors", [])
    failed_agents = state.get("failed_agents", [])
    current_agent = state.get("current_agent", "")
    
    print(f"🔧 错误恢复路由器检查状态...")
    
    # 检查是否有失败的代理
    if failed_agents:
        print(f"⚠️ 检测到失败代理: {failed_agents}")
        return "fallback_mode"
    
    # 检查是否需要重试
    retry_count = state.get("retry_count", {})
    for agent, count in retry_count.items():
        if count > 0 and count < 3 and agent not in state.get("completed_agents", []):
            print(f"🔄 代理 {agent} 需要重试")
            return "retry"
    
    # 正常继续
    if current_agent == "researcher":
        return "continue_to_analyzer"
    else:
        return "finalize"

def generate_execution_summary(state: RobustAgentState):
    """📋 生成执行总结"""
    completed = state.get("completed_agents", [])
    failed = state.get("failed_agents", [])
    errors = state.get("errors", [])
    agent_results = state.get("agent_results", {})
    
    # 生成最终结果
    if agent_results:
        final_result = "执行完成\n\n"
        for agent, result in agent_results.items():
            final_result += f"## {agent}结果\n"
            final_result += f"{result.get('summary', '无结果')}\n"
            final_result += f"置信度: {result.get('confidence', 0):.2f}\n\n"
    else:
        final_result = "执行失败：所有代理都无法完成任务"
    
    # 生成执行摘要
    summary = {
        "total_agents": len(completed) + len(failed),
        "completed_agents": completed,
        "failed_agents": failed,
        "total_errors": len(errors),
        "fallback_used": state.get("fallback_mode", False),
        "overall_success": len(completed) > 0
    }
    
    return {
        "final_result": final_result,
        "execution_summary": summary
    }

def should_retry(state: RobustAgentState):
    """判断是否应该重试"""
    retry_count = state.get("retry_count", {})
    failed_agents = state.get("failed_agents", [])
    
    # 如果有代理失败但重试次数未达上限，则重试
    for agent, count in retry_count.items():
        if count > 0 and count < 3 and agent not in failed_agents:
            return True
    
    return False

def create_robust_agent_system():
    """创建具有容错能力的代理系统"""
    workflow = StateGraph(RobustAgentState)
    
    # 添加代理节点
    workflow.add_node("researcher", resilient_researcher)
    workflow.add_node("analyzer", resilient_analyzer)
    workflow.add_node("summarizer", generate_execution_summary)
    
    # 设置入口
    workflow.set_entry_point("researcher")
    
    # 复杂的条件路由
    workflow.add_conditional_edges(
        "researcher",
        error_recovery_router,
        {
            "retry": "researcher",           # 重试研究代理
            "fallback_mode": "analyzer",     # 进入降级模式
            "continue_to_analyzer": "analyzer" # 正常继续
        }
    )
    
    workflow.add_conditional_edges(
        "analyzer",
        lambda state: "summarizer",  # 分析完成后直接总结
        {
            "summarizer": "summarizer"
        }
    )
    
    workflow.add_edge("summarizer", END)
    
    return workflow.compile()

# 测试容错系统
if __name__ == "__main__":
    app = create_robust_agent_system()
    
    result = app.invoke({
        "task_description": "分析云计算技术的发展趋势"
    })
    
    print("\n" + "="*60)
    print("🛡️ 容错代理系统执行结果")
    print("="*60)
    
    summary = result["execution_summary"]
    print(f"总代理数: {summary['total_agents']}")
    print(f"成功代理: {summary['completed_agents']}")
    print(f"失败代理: {summary['failed_agents']}")
    print(f"错误总数: {summary['total_errors']}")
    print(f"使用降级模式: {summary['fallback_used']}")
    print(f"整体成功: {summary['overall_success']}")
    
    print(f"\n📋 执行结果:")
    print(result["final_result"])
    
    if result.get("errors"):
        print(f"\n❌ 错误记录:")
        for error in result["errors"]:
            print(f"- {error['agent']}: {error['type']} - {error['message']}")
```

## 🎓 学习检验清单

完成本章学习后，你应该能够：

**基础能力**：
- [ ] 解释多代理协作的优势和适用场景
- [ ] 设计合理的代理分工和职责
- [ ] 实现简单的双代理协作系统
- [ ] 集成基本的外部工具扩展代理能力

**进阶能力**：
- [ ] 构建复杂的多代理流水线系统
- [ ] 实现并行协作和反馈循环协作
- [ ] 设计工具管理和调用机制
- [ ] 处理多代理系统的状态管理复杂性

**高级能力**：
- [ ] 实现多代理系统的容错和恢复机制
- [ ] 优化代理间的协作效率
- [ ] 设计可扩展的多代理架构
- [ ] 解决复杂的代理协调和冲突问题

**实战能力**：
- [ ] 分析复杂业务需求，设计多代理解决方案
- [ ] 构建生产级的多代理协作系统
- [ ] 调试和优化多代理系统的性能
- [ ] 向团队解释多代理系统的架构设计

## 🔮 思考题和练习

**基础练习**：
1. 设计一个简单的多代理翻译系统：检测语言→翻译→质检→格式化
2. 实现一个代码审查协作系统：代码分析→安全检查→性能分析→报告生成
3. 构建一个智能客服系统：意图识别→知识检索→回复生成→满意度评估

**进阶练习**：
1. 设计一个多代理数据分析平台：数据收集→清洗→分析→可视化→报告
2. 实现一个内容营销协作系统：趋势分析→内容策划→创作→优化→发布
3. 构建一个智能招聘系统：简历筛选→技能评估→面试安排→决策建议

**高级练习**：
1. 设计一个容错的分布式爬虫系统：多代理并行爬取，支持故障恢复
2. 实现一个智能投资顾问：市场分析→风险评估→策略推荐→执行监控
3. 构建一个自适应学习系统：内容推荐→学习监控→效果评估→策略调整

**架构思考**：
1. 如何设计多代理系统的通信协议和消息格式？
2. 在什么情况下应该选择顺序协作vs并行协作vs反馈协作？
3. 如何平衡代理的专业化程度和系统的灵活性？
4. 多代理系统的性能瓶颈通常在哪里，如何优化？

---

**🎯 恭喜！** 你已经掌握了LangGraph的精髓——多代理协作。现在你可以构建由专业化AI代理组成的强大团队，解决复杂的现实问题！

**👉 下一步**: [L4: 高级特性与性能优化](./04-高级特性与性能优化.md) - 让你的多代理系统达到生产级性能！