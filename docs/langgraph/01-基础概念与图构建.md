# L1: 基础概念与图构建

**学习目标**: 掌握LangGraph核心概念，构建第一个图工作流  
**预计用时**: 2-3小时  
**前置知识**: Python基础、LangChain基本概念

## 🌟 核心概念理解

### 1.1 为什么需要LangGraph？

**传统AI工作流的局限性**：
```python
# 传统LangChain链式结构
from langchain.chains import LLMChain

# 线性执行，状态管理复杂
chain = prompt | llm | output_parser
result = chain.invoke({"input": "用户输入"})
```

**问题分析**：
- ❌ **状态孤立**: 每个组件的状态互不相通
- ❌ **单向流动**: 只能从前向后执行，无法回溯或分支
- ❌ **扩展困难**: 添加新逻辑需要重构整个链
- ❌ **错误恢复**: 失败后无法从中间节点恢复

### 1.2 LangGraph的革命性解决方案

**图状态管理模式**：
```python
# LangGraph图状态结构
from langgraph.graph import StateGraph
from typing_extensions import TypedDict

class GraphState(TypedDict):
    messages: list
    current_step: str
    context: dict

# 每个节点都可以访问和修改全局状态
graph = StateGraph(GraphState)
```

**核心优势**：
- ✅ **状态共享**: 所有节点共享统一的全局状态
- ✅ **灵活路由**: 支持条件分支、循环和回溯
- ✅ **模块化**: 每个节点独立开发和测试
- ✅ **可恢复**: 支持状态持久化和断点恢复

## 🏗️ 核心组件深度解析

### 2.1 StateGraph - 图的构建者

**组件职责**：
- 🎯 **图结构定义**: 管理节点和边的关系
- 🔄 **状态管理**: 维护全局状态的一致性
- 🚦 **执行控制**: 控制工作流的执行顺序和条件

**基础使用模式**：
```python
from langgraph.graph import StateGraph, END
from typing_extensions import TypedDict

# 1. 定义状态结构
class AgentState(TypedDict):
    input: str
    chat_history: list
    intermediate_steps: list

# 2. 创建图实例
workflow = StateGraph(AgentState)

# 3. 添加节点
workflow.add_node("researcher", research_node)
workflow.add_node("writer", write_node)

# 4. 定义边关系
workflow.add_edge("researcher", "writer")
workflow.add_edge("writer", END)

# 5. 设置入口点
workflow.set_entry_point("researcher")
```

### 2.2 Node - 执行的基本单元

**节点类型分类**：

**1. 函数节点** (最常用)
```python
def research_node(state: AgentState):
    """研究节点 - 收集信息"""
    query = state["input"]
    # 执行研究逻辑
    research_results = perform_research(query)
    
    # 返回状态更新
    return {
        "intermediate_steps": state["intermediate_steps"] + [
            {"action": "research", "result": research_results}
        ]
    }
```

**2. LLM节点** (AI推理)
```python
def llm_node(state: AgentState):
    """LLM推理节点"""
    prompt = create_prompt(state)
    response = llm.invoke(prompt)
    
    return {
        "chat_history": state["chat_history"] + [
            {"role": "assistant", "content": response.content}
        ]
    }
```

**3. 工具节点** (外部调用)
```python
def tool_node(state: AgentState):
    """工具调用节点"""
    tool_call = state["intermediate_steps"][-1]
    result = execute_tool(tool_call["tool"], tool_call["input"])
    
    return {
        "intermediate_steps": state["intermediate_steps"] + [
            {"action": "tool_result", "result": result}
        ]
    }
```

### 2.3 State - 状态管理的核心

**状态设计原则**：

**1. 类型安全设计**
```python
from typing_extensions import TypedDict, NotRequired
from typing import List, Dict, Any

class ComprehensiveState(TypedDict):
    # 必需字段
    input: str
    output: str
    
    # 可选字段 
    chat_history: NotRequired[List[Dict[str, str]]]
    metadata: NotRequired[Dict[str, Any]]
    
    # 控制字段
    current_step: NotRequired[str]
    error_message: NotRequired[str]
```

**2. 状态更新机制**
```python
# 增量更新 (推荐)
def node_function(state: ComprehensiveState):
    return {
        "chat_history": state.get("chat_history", []) + [new_message],
        "current_step": "processing"
    }

# 全量更新 (谨慎使用)
def full_update_node(state: ComprehensiveState):
    return {
        **state,
        "output": "完成处理",
        "current_step": "completed"
    }
```

## 💻 第一个完整示例

### 3.1 智能问答系统

**业务场景**: 构建一个具有研究能力的AI助手，能够先搜索信息再生成回答。

**完整实现**：

```python
from langgraph.graph import StateGraph, END
from typing_extensions import TypedDict, NotRequired
import json

# 1. 状态定义
class QAState(TypedDict):
    question: str
    research_query: NotRequired[str]
    search_results: NotRequired[list]
    final_answer: NotRequired[str]
    step_history: NotRequired[list]

# 2. 节点实现
def query_analysis_node(state: QAState):
    """分析问题，生成搜索查询"""
    question = state["question"]
    
    # 简单的查询提取逻辑 (实际场景中使用LLM)
    research_query = f"详细解释 {question}"
    
    return {
        "research_query": research_query,
        "step_history": state.get("step_history", []) + ["查询分析完成"]
    }

def research_node(state: QAState):
    """执行信息搜索"""
    query = state["research_query"]
    
    # 模拟搜索结果
    mock_results = [
        {"title": "相关文档1", "content": f"关于{query}的详细信息..."},
        {"title": "相关文档2", "content": f"{query}的实际应用案例..."}
    ]
    
    return {
        "search_results": mock_results,
        "step_history": state.get("step_history", []) + ["信息搜索完成"]
    }

def answer_generation_node(state: QAState):
    """基于搜索结果生成最终答案"""
    question = state["question"]
    results = state["search_results"]
    
    # 整合信息生成答案 (实际场景中使用LLM)
    context = "\n".join([r["content"] for r in results])
    final_answer = f"基于搜索结果，{question}的答案是：\n{context[:200]}..."
    
    return {
        "final_answer": final_answer,
        "step_history": state.get("step_history", []) + ["答案生成完成"]
    }

# 3. 构建工作流
def create_qa_workflow():
    workflow = StateGraph(QAState)
    
    # 添加节点
    workflow.add_node("analyze", query_analysis_node)
    workflow.add_node("research", research_node)  
    workflow.add_node("answer", answer_generation_node)
    
    # 定义执行流程
    workflow.set_entry_point("analyze")
    workflow.add_edge("analyze", "research")
    workflow.add_edge("research", "answer")
    workflow.add_edge("answer", END)
    
    return workflow.compile()

# 4. 使用示例
if __name__ == "__main__":
    app = create_qa_workflow()
    
    # 执行查询
    result = app.invoke({
        "question": "什么是LangGraph？"
    })
    
    print("=== 执行结果 ===")
    print(f"问题: {result['question']}")
    print(f"搜索查询: {result['research_query']}")
    print(f"最终答案: {result['final_answer']}")
    print(f"执行历史: {result['step_history']}")
```

### 3.2 运行结果分析

**预期输出**：
```
=== 执行结果 ===
问题: 什么是LangGraph？
搜索查询: 详细解释 什么是LangGraph？
最终答案: 基于搜索结果，什么是LangGraph？的答案是：
关于详细解释 什么是LangGraph？的详细信息...
详细解释 什么是LangGraph？的实际应用案例...
执行历史: ['查询分析完成', '信息搜索完成', '答案生成完成']
```

**关键观察点**：
- ✅ **状态传递**: 每个节点都能访问前面节点的处理结果
- ✅ **增量更新**: `step_history`逐步累积执行记录
- ✅ **模块化**: 每个节点职责单一，易于测试和维护
- ✅ **可扩展**: 可以轻松添加新的处理节点

## 🎯 核心概念对比

### 4.1 LangGraph vs 传统链式结构

| 特性维度 | 传统LangChain链 | LangGraph图结构 |
|---------|----------------|----------------|
| **状态管理** | 每个组件独立状态 | 全局共享状态 |
| **执行模式** | 严格线性执行 | 灵活的图执行 |
| **错误处理** | 链式传播，难以恢复 | 节点级处理，支持重试 |
| **扩展性** | 需重构整个链 | 增加节点和边即可 |
| **调试性** | 黑盒式执行 | 状态可观测，步骤可追踪 |
| **复用性** | 组件耦合度高 | 节点独立，高度复用 |

### 4.2 设计哲学差异

**LangChain链式哲学**：
```python
# 线性思维：输入 → 处理 → 输出
chain = prompt | llm | parser | validator
result = chain.invoke(input)
```

**LangGraph图式哲学**：
```python
# 图状态思维：状态 → 节点转换 → 新状态
graph = StateGraph(State)
graph.add_node("process", transform_state)
graph.add_edge("process", conditional_next)
app = graph.compile()
```

## 📋 最佳实践指南

### 5.1 状态设计最佳实践

**1. 类型安全优先**
```python
# ✅ 推荐：使用TypedDict确保类型安全
class MyState(TypedDict):
    required_field: str
    optional_field: NotRequired[int]

# ❌ 避免：使用普通字典
state = {"field1": "value1", "field2": 42}
```

**2. 最小化状态原则**
```python
# ✅ 推荐：只保留必要的状态
class MinimalState(TypedDict):
    user_input: str
    processed_result: str
    
# ❌ 避免：状态臃肿
class BloatedState(TypedDict):
    everything_you_can_imagine: Any
```

**3. 状态版本控制**
```python
# ✅ 推荐：状态变化可追踪
class VersionedState(TypedDict):
    data: str
    version: int
    last_modified_by: str
```

### 5.2 节点设计最佳实践

**1. 单一职责原则**
```python
# ✅ 推荐：每个节点职责单一
def validate_input(state): # 只负责验证
    pass

def process_data(state):   # 只负责处理
    pass

# ❌ 避免：节点职责过重
def validate_and_process_and_save(state):
    pass
```

**2. 幂等性设计**
```python
# ✅ 推荐：幂等操作，可重复执行
def idempotent_node(state):
    if not state.get("processed", False):
        # 执行处理逻辑
        return {"processed": True, "result": "xxx"}
    return {}  # 已处理，不重复执行
```

## 🔮 进阶预告

**L2层预告 - 状态管理与条件路由**：
- 🎯 **条件边设计**: 根据状态动态选择下一个节点
- 🔄 **循环控制**: 实现迭代优化和重试机制
- 🧠 **智能路由**: 构建具有决策能力的工作流
- ⚡ **性能优化**: 状态更新和内存管理技巧

## 📝 练习与思考

**基础练习**：
1. 修改示例中的QA系统，添加一个"结果验证"节点
2. 设计一个简单的内容生成工作流：输入主题 → 大纲生成 → 内容写作 → 质量检查
3. 实现一个多步骤数据处理流程，体验状态在节点间的传递

**思考题**：
1. 什么场景下应该使用LangGraph而不是传统的LangChain链？
2. 如何设计状态结构才能最好地支持未来的扩展需求？
3. 节点的粒度应该如何把握？太细和太粗各有什么问题？

---

**🎯 学习检验**: 完成本章学习后，你应该能够独立构建一个具有3-5个节点的简单图工作流，并理解状态在节点间的传递机制。

**👉 下一步**: [L2: 状态管理与条件路由](./02-状态管理与条件路由.md) - 让你的工作流具备决策能力！