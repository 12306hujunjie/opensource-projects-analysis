# L2: 状态管理与条件路由

**学习目标**: 让AI工作流具备智能决策能力  
**预计用时**: 3-4小时  
**核心转变**: 从"数据传递"思维 → "决策制定"思维

*💡 从这一章开始，你将学会让AI工作流真正"智能"起来——不再是机械的步骤执行，而是能够根据情况做出不同的决策。*

---

## 🎯 开篇：神奇的自动决策

### 让人着迷的现象

你有没有好奇过，为什么同样是AI助手，有些能够：

```python
# 用户输入："今天北京天气怎么样？"
# AI自动决定：需要调用天气API，获取实时数据

# 用户输入："什么是递归算法？" 
# AI自动决定：直接回答，不需要外部工具

# 用户输入："这段代码有什么问题？[代码片段]"
# AI自动决定：进入代码分析模式，逐行检查

# 用户输入："帮我写一首关于秋天的诗"
# AI自动决定：进入创作模式，调用创意生成流程
```

**这种"智能"是如何实现的？** 🤔

它看起来像魔法，但实际上是精心设计的**条件路由系统**在起作用。今天我们就来揭开这个秘密，让你的AI工作流也具备这种"智能决策"的能力！

### 从熟悉的概念开始

如果用传统编程思维，你可能会这样处理：

```python
# 传统的if-else方式
def handle_user_input(user_input):
    if "天气" in user_input:
        return call_weather_api(user_input)
    elif "什么是" in user_input:
        return generate_explanation(user_input)
    elif "代码" in user_input and "问题" in user_input:
        return analyze_code(user_input)
    else:
        return default_response(user_input)
```

**问题来了**：
- ❌ 逻辑越来越复杂，代码变得难以维护
- ❌ 每次添加新功能都要修改主函数
- ❌ 状态无法在不同处理步骤间共享
- ❌ 错误处理和重试机制难以实现

**LangGraph的解决方案**：把决策逻辑分布到图的边上，让每个节点专注于自己的职责，让状态在整个图中自由流动。

## 🧠 核心概念：从数据传递到决策制定

### 思维模式的转换

**L1阶段的思维**（数据传递）：
```
输入 → 节点A → 节点B → 节点C → 输出
```

**L2阶段的思维**（决策制定）：
```
输入 → 分析状态 → 根据条件选择路径 → 执行对应逻辑 → 检查结果 → 决定下一步
```

这就像GPS导航系统：
- 🗺️ **状态** = 你当前的位置、目的地、交通状况
- 🤔 **条件判断** = 分析路况，选择最优路线
- 🛣️ **路由** = 实际的行进路径
- 🔄 **重新规划** = 遇到堵车时的重新路由

## 💻 第一个智能路由：内容处理系统

让我们从一个简单但实用的例子开始：**智能内容处理系统**

### 需求分析

假设你要构建一个内容处理系统：
- 📝 短内容（<100字）：直接发布
- 📄 长内容（≥100字）：需要质量检查
- 🔍 检查通过：自动发布
- ⚠️ 检查不通过：人工审核

### 第一版：简单二元决策

```python
from langgraph.graph import StateGraph, END
from typing_extensions import TypedDict, NotRequired

# 1. 状态定义
class ContentState(TypedDict):
    content: str
    content_length: NotRequired[int]
    quality_score: NotRequired[float]
    status: NotRequired[str]  # "draft", "checked", "published", "rejected"
    process_history: NotRequired[list]

# 2. 节点实现
def analyze_content(state: ContentState):
    """分析内容基本信息"""
    content = state["content"]
    length = len(content)
    
    return {
        "content_length": length,
        "status": "analyzed",
        "process_history": state.get("process_history", []) + ["内容分析完成"]
    }

def publish_directly(state: ContentState):
    """短内容直接发布"""
    return {
        "status": "published",
        "process_history": state.get("process_history", []) + ["短内容直接发布"]
    }

def quality_check(state: ContentState):
    """质量检查（模拟）"""
    # 简单的质量评分逻辑
    content = state["content"]
    score = min(90, len(content.split()) * 2 + 50)  # 模拟评分
    
    return {
        "quality_score": score,
        "status": "checked",
        "process_history": state.get("process_history", []) + [f"质量检查完成，得分: {score}"]
    }

def publish_content(state: ContentState):
    """发布内容"""
    return {
        "status": "published",
        "process_history": state.get("process_history", []) + ["内容发布成功"]
    }

def manual_review(state: ContentState):
    """人工审核"""
    return {
        "status": "pending_review",
        "process_history": state.get("process_history", []) + ["提交人工审核"]
    }

# 3. 条件函数（决策的核心！）
def is_short_content(state: ContentState):
    """判断是否为短内容"""
    return state.get("content_length", 0) < 100

def is_quality_good(state: ContentState):
    """判断质量是否合格"""
    return state.get("quality_score", 0) >= 80

# 4. 构建智能路由图
def create_content_processor():
    workflow = StateGraph(ContentState)
    
    # 添加节点
    workflow.add_node("analyze", analyze_content)
    workflow.add_node("publish_directly", publish_directly)
    workflow.add_node("quality_check", quality_check)
    workflow.add_node("publish", publish_content)
    workflow.add_node("manual_review", manual_review)
    
    # 设置入口
    workflow.set_entry_point("analyze")
    
    # 第一个决策点：长短内容分流
    workflow.add_conditional_edges(
        "analyze",
        is_short_content,
        {
            True: "publish_directly",   # 短内容直接发布
            False: "quality_check"      # 长内容质量检查
        }
    )
    
    # 第二个决策点：质量检查结果
    workflow.add_conditional_edges(
        "quality_check", 
        is_quality_good,
        {
            True: "publish",           # 质量好，自动发布
            False: "manual_review"     # 质量差，人工审核
        }
    )
    
    # 终止节点
    workflow.add_edge("publish_directly", END)
    workflow.add_edge("publish", END)
    workflow.add_edge("manual_review", END)
    
    return workflow.compile()

# 5. 测试运行
if __name__ == "__main__":
    app = create_content_processor()
    
    # 测试短内容
    result1 = app.invoke({
        "content": "今天天气不错！"
    })
    print("=== 短内容处理结果 ===")
    print(f"状态: {result1['status']}")
    print(f"处理历史: {result1['process_history']}")
    
    # 测试长内容（高质量）
    result2 = app.invoke({
        "content": "人工智能技术的发展日新月异，从最初的规则系统到现在的深度学习，我们见证了技术的巨大飞跃。" * 3
    })
    print("\n=== 长内容（高质量）处理结果 ===")
    print(f"状态: {result2['status']}")
    print(f"质量得分: {result2.get('quality_score')}")
    print(f"处理历史: {result2['process_history']}")
```

### 🔍 深入理解：这里发生了什么？

**1. 条件函数是决策的大脑**
```python
def is_short_content(state: ContentState):
    return state.get("content_length", 0) < 100
```
- 这个函数查看当前状态，返回True/False
- LangGraph根据返回值决定下一个节点
- 简单但强大！

**2. add_conditional_edges的魔法**
```python
workflow.add_conditional_edges(
    "analyze",              # 从哪个节点出发
    is_short_content,       # 用什么条件判断
    {
        True: "publish_directly",   # 条件为真时去哪里
        False: "quality_check"      # 条件为假时去哪里
    }
)
```

**3. 状态的智能演进**
```python
# 初始状态
{"content": "今天天气不错！"}

# 经过analyze节点后
{
    "content": "今天天气不错！",
    "content_length": 8,
    "status": "analyzed",
    "process_history": ["内容分析完成"]
}

# 路由决策：8 < 100，所以走短内容路径
# 最终状态
{
    "content": "今天天气不错！",
    "content_length": 8,
    "status": "published",
    "process_history": ["内容分析完成", "短内容直接发布"]
}
```

## 🚀 试试修改和实验

**实验1：调整判断阈值**
```python
# 试试把短内容的阈值改成50
def is_short_content(state: ContentState):
    return state.get("content_length", 0) < 50  # 原来是100
```

**实验2：添加新的路由路径**
```python
# 添加中等内容的处理逻辑
def is_medium_content(state: ContentState):
    length = state.get("content_length", 0)
    return 50 <= length < 100

workflow.add_conditional_edges(
    "analyze",
    lambda state: "short" if state.get("content_length", 0) < 50 
                 else "medium" if state.get("content_length", 0) < 100 
                 else "long",
    {
        "short": "publish_directly",
        "medium": "simple_check",     # 新增：简单检查
        "long": "quality_check"
    }
)
```

**实验3：查看执行路径**
```python
# 添加调试信息
def analyze_content(state: ContentState):
    content = state["content"]
    length = len(content)
    print(f"🔍 分析内容: 长度={length}, 内容预览='{content[:20]}...'")
    return {
        "content_length": length,
        "status": "analyzed",
        "process_history": state.get("process_history", []) + ["内容分析完成"]
    }
```

## 🎨 进阶：复杂条件和多路径路由

现在让我们升级系统，处理更复杂的决策场景：

### 智能内容分类器

```python
from typing import Literal

# 扩展状态定义
class AdvancedContentState(TypedDict):
    content: str
    content_type: NotRequired[Literal["tech", "marketing", "news", "creative"]]
    urgency_level: NotRequired[Literal["low", "medium", "high"]]
    quality_score: NotRequired[float]
    target_audience: NotRequired[str]
    processing_path: NotRequired[str]
    process_history: NotRequired[list]

def analyze_content_advanced(state: AdvancedContentState):
    """高级内容分析"""
    content = state["content"]
    
    # 简单的内容分类逻辑（实际项目中会用ML模型）
    content_type = "tech"
    if any(word in content.lower() for word in ["营销", "推广", "销售"]):
        content_type = "marketing"
    elif any(word in content.lower() for word in ["新闻", "报道", "事件"]):
        content_type = "news"
    elif any(word in content.lower() for word in ["故事", "诗歌", "创作"]):
        content_type = "creative"
        
    # 紧急程度分析
    urgency = "low"
    if "紧急" in content or "立即" in content:
        urgency = "high"
    elif "尽快" in content or "优先" in content:
        urgency = "medium"
    
    return {
        "content_type": content_type,
        "urgency_level": urgency,
        "process_history": state.get("process_history", []) + 
                          [f"分析完成: 类型={content_type}, 紧急度={urgency}"]
    }

def intelligent_router(state: AdvancedContentState):
    """智能路由决策"""
    content_type = state.get("content_type", "tech")
    urgency = state.get("urgency_level", "low")
    
    # 复杂的路由逻辑
    if urgency == "high":
        return "urgent_track"
    elif content_type == "marketing":
        return "marketing_review"
    elif content_type == "tech":
        return "tech_review"
    elif content_type == "creative":
        return "creative_review"
    else:
        return "general_review"

# 构建复杂路由图
def create_advanced_processor():
    workflow = StateGraph(AdvancedContentState)
    
    # 添加分析节点
    workflow.add_node("analyze", analyze_content_advanced)
    
    # 添加各种处理节点
    workflow.add_node("urgent_track", lambda state: {
        "processing_path": "urgent", 
        "process_history": state.get("process_history", []) + ["紧急通道处理"]
    })
    
    workflow.add_node("marketing_review", lambda state: {
        "processing_path": "marketing",
        "process_history": state.get("process_history", []) + ["营销内容审核"]
    })
    
    workflow.add_node("tech_review", lambda state: {
        "processing_path": "tech",
        "process_history": state.get("process_history", []) + ["技术内容审核"]
    })
    
    workflow.add_node("creative_review", lambda state: {
        "processing_path": "creative", 
        "process_history": state.get("process_history", []) + ["创意内容审核"]
    })
    
    workflow.add_node("general_review", lambda state: {
        "processing_path": "general",
        "process_history": state.get("process_history", []) + ["通用内容审核"]
    })
    
    # 设置入口和智能路由
    workflow.set_entry_point("analyze")
    workflow.add_conditional_edges(
        "analyze",
        intelligent_router,
        {
            "urgent_track": "urgent_track",
            "marketing_review": "marketing_review", 
            "tech_review": "tech_review",
            "creative_review": "creative_review",
            "general_review": "general_review"
        }
    )
    
    # 所有路径都结束
    for node in ["urgent_track", "marketing_review", "tech_review", "creative_review", "general_review"]:
        workflow.add_edge(node, END)
    
    return workflow.compile()
```

### 🔥 循环和迭代：质量改进系统

有时候我们需要循环执行某些步骤，直到达到满意的结果：

```python
class IterativeContentState(TypedDict):
    content: str
    quality_score: NotRequired[float]
    improvement_count: NotRequired[int]
    improvement_suggestions: NotRequired[list]
    final_result: NotRequired[str]
    process_history: NotRequired[list]

def check_quality(state: IterativeContentState):
    """质量检查"""
    content = state["content"]
    
    # 模拟质量评分（实际项目中会用AI模型）
    base_score = len(content.split()) * 2  # 基础分：词数 × 2
    length_bonus = min(20, len(content) // 10)  # 长度奖励
    quality_score = min(100, base_score + length_bonus)
    
    # 生成改进建议
    suggestions = []
    if quality_score < 60:
        suggestions.append("内容过于简短，需要更多细节")
    if quality_score < 80:
        suggestions.append("可以添加更多例子和说明")
    
    return {
        "quality_score": quality_score,
        "improvement_suggestions": suggestions,
        "process_history": state.get("process_history", []) + 
                          [f"质量检查: 得分={quality_score}"]
    }

def improve_content(state: IterativeContentState):
    """改进内容"""
    current_content = state["content"]
    suggestions = state.get("improvement_suggestions", [])
    count = state.get("improvement_count", 0) + 1
    
    # 模拟内容改进（实际项目中会用AI）
    improved_content = current_content
    if "更多细节" in " ".join(suggestions):
        improved_content += " 这里是补充的详细信息和背景说明。"
    if "更多例子" in " ".join(suggestions):
        improved_content += " 例如：相关的案例和实际应用场景。"
    
    return {
        "content": improved_content,
        "improvement_count": count,
        "process_history": state.get("process_history", []) + 
                          [f"第{count}次改进完成"]
    }

def finalize_content(state: IterativeContentState):
    """最终确定内容"""
    return {
        "final_result": state["content"],
        "process_history": state.get("process_history", []) + ["内容最终确定"]
    }

# 循环控制的关键函数
def should_continue_improving(state: IterativeContentState):
    """决定是否继续改进"""
    quality_score = state.get("quality_score", 0)
    improvement_count = state.get("improvement_count", 0)
    
    # 质量足够好或者已经改进了3次，就停止
    return quality_score < 80 and improvement_count < 3

def create_iterative_processor():
    workflow = StateGraph(IterativeContentState)
    
    # 添加节点
    workflow.add_node("check_quality", check_quality)
    workflow.add_node("improve", improve_content)
    workflow.add_node("finalize", finalize_content)
    
    # 设置入口
    workflow.set_entry_point("check_quality")
    
    # 核心：循环控制
    workflow.add_conditional_edges(
        "check_quality",
        should_continue_improving,
        {
            True: "improve",      # 继续改进
            False: "finalize"     # 结束流程
        }
    )
    
    # 改进后重新检查（形成循环）
    workflow.add_edge("improve", "check_quality")
    workflow.add_edge("finalize", END)
    
    return workflow.compile()

# 测试循环改进
if __name__ == "__main__":
    app = create_iterative_processor()
    
    result = app.invoke({
        "content": "这是一个简短的内容。"
    })
    
    print("=== 循环改进结果 ===")
    print(f"最终内容: {result['final_result']}")
    print(f"质量得分: {result['quality_score']}")
    print(f"改进次数: {result.get('improvement_count', 0)}")
    print(f"处理历史: {result['process_history']}")
```

## 🎯 状态设计的艺术

### 好的状态设计 vs 坏的状态设计

**❌ 坏的状态设计**：
```python
class BadState(TypedDict):
    everything: Any  # 把所有东西都塞进一个字段
    data1: str       # 不清楚的命名
    data2: int       # 没有类型提示的可选字段
    temp_var: str    # 临时变量混在状态里
```

**✅ 好的状态设计**：
```python
class GoodState(TypedDict):
    # 核心业务数据
    user_input: str
    processing_result: NotRequired[str]
    
    # 控制信息
    current_step: NotRequired[str]
    retry_count: NotRequired[int]
    
    # 元数据
    created_at: NotRequired[str]
    processing_history: NotRequired[List[str]]
    
    # 错误处理
    error_message: NotRequired[str]
    last_error: NotRequired[Dict[str, Any]]
```

### 状态设计的黄金原则

**1. 分层设计**
```python
class LayeredState(TypedDict):
    # 第1层：业务数据
    input_data: str
    output_data: NotRequired[str]
    
    # 第2层：流程控制
    current_phase: NotRequired[str]
    completion_status: NotRequired[float]  # 0-1之间
    
    # 第3层：质量保证
    validation_results: NotRequired[Dict[str, bool]]
    quality_metrics: NotRequired[Dict[str, float]]
    
    # 第4层：调试信息
    debug_info: NotRequired[Dict[str, Any]]
    execution_trace: NotRequired[List[str]]
```

**2. 状态验证**
```python
def validate_state(state: GoodState) -> bool:
    """状态验证函数"""
    # 必需字段检查
    if "user_input" not in state:
        return False
    
    # 数据类型检查
    if "retry_count" in state and not isinstance(state["retry_count"], int):
        return False
        
    # 业务逻辑检查
    if state.get("retry_count", 0) > 5:
        return False
        
    return True

def safe_node_function(state: GoodState):
    """带状态验证的节点函数"""
    if not validate_state(state):
        return {
            "error_message": "状态验证失败",
            "current_step": "error"
        }
    
    # 正常处理逻辑
    return {"processing_result": "success"}
```

## 🛠️ 实用技巧和最佳实践

### 调试条件路由

**1. 添加路由日志**
```python
def debug_router(state: ContentState):
    """带调试信息的路由函数"""
    content_length = state.get("content_length", 0)
    quality_score = state.get("quality_score", 0)
    
    print(f"🔍 路由决策:")
    print(f"   内容长度: {content_length}")
    print(f"   质量得分: {quality_score}")
    
    if content_length < 100:
        print(f"   决策: 短内容 → 直接发布")
        return "publish_directly"
    elif quality_score >= 80:
        print(f"   决策: 长内容+高质量 → 自动发布")
        return "publish"
    else:
        print(f"   决策: 长内容+低质量 → 人工审核")
        return "manual_review"
```

**2. 状态快照**
```python
def take_state_snapshot(state: Any, step_name: str):
    """保存状态快照用于调试"""
    import json
    import datetime
    
    snapshot = {
        "timestamp": datetime.datetime.now().isoformat(),
        "step": step_name,
        "state": dict(state)
    }
    
    # 保存到文件或打印
    print(f"📸 状态快照 [{step_name}]:")
    print(json.dumps(snapshot, indent=2, ensure_ascii=False))
```

### 性能优化技巧

**1. 避免不必要的状态复制**
```python
# ❌ 避免：完全复制状态
def inefficient_node(state: LargeState):
    return {**state, "new_field": "value"}  # 复制了整个状态

# ✅ 推荐：只返回变化的部分
def efficient_node(state: LargeState):
    return {"new_field": "value"}  # 只返回新增/修改的字段
```

**2. 条件函数的性能优化**
```python
# ❌ 避免：复杂的计算在条件函数中
def slow_condition(state):
    # 复杂的AI推理或大量计算
    return expensive_ai_call(state["content"]) > 0.8

# ✅ 推荐：预先计算，条件函数只做简单判断
def fast_condition(state):
    # 在前面的节点中已经计算好了分数
    return state.get("computed_score", 0) > 0.8
```

## 🎪 综合实战：智能客服路由系统

让我们用一个完整的例子来整合所有概念：

```python
from enum import Enum

class Intent(str, Enum):
    TECHNICAL_SUPPORT = "technical_support"
    BILLING_INQUIRY = "billing_inquiry" 
    GENERAL_QUESTION = "general_question"
    COMPLAINT = "complaint"
    SALES = "sales"

class Priority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class CustomerServiceState(TypedDict):
    user_message: str
    user_id: NotRequired[str]
    user_tier: NotRequired[str]  # "basic", "premium", "vip"
    
    # 分析结果
    detected_intent: NotRequired[Intent]
    priority_level: NotRequired[Priority]
    sentiment_score: NotRequired[float]  # -1 to 1
    
    # 路由决策
    assigned_queue: NotRequired[str]
    estimated_wait_time: NotRequired[int]
    
    # 处理历史
    routing_history: NotRequired[List[str]]

def analyze_user_message(state: CustomerServiceState):
    """分析用户消息"""
    message = state["user_message"].lower()
    user_tier = state.get("user_tier", "basic")
    
    # 意图识别（简化版）
    intent = Intent.GENERAL_QUESTION
    if any(word in message for word in ["bug", "error", "not working", "broken"]):
        intent = Intent.TECHNICAL_SUPPORT
    elif any(word in message for word in ["bill", "charge", "payment", "refund"]):
        intent = Intent.BILLING_INQUIRY
    elif any(word in message for word in ["angry", "terrible", "worst", "complaint"]):
        intent = Intent.COMPLAINT
    elif any(word in message for word in ["buy", "purchase", "price", "plan"]):
        intent = Intent.SALES
    
    # 情感分析（简化版）
    sentiment = 0.0
    if any(word in message for word in ["angry", "terrible", "hate", "awful"]):
        sentiment = -0.8
    elif any(word in message for word in ["love", "great", "awesome", "perfect"]):
        sentiment = 0.8
    
    # 优先级计算
    priority = Priority.LOW
    if user_tier == "vip":
        priority = Priority.HIGH
    elif user_tier == "premium":
        priority = Priority.MEDIUM
        
    if intent == Intent.COMPLAINT or sentiment < -0.5:
        priority = Priority.URGENT if user_tier == "vip" else Priority.HIGH
    elif intent == Intent.TECHNICAL_SUPPORT:
        priority = Priority.MEDIUM if priority == Priority.LOW else priority
    
    return {
        "detected_intent": intent,
        "priority_level": priority,
        "sentiment_score": sentiment,
        "routing_history": state.get("routing_history", []) + 
                          [f"分析完成: {intent.value}, 优先级: {priority.value}"]
    }

def route_to_technical(state: CustomerServiceState):
    """技术支持队列"""
    priority = state["priority_level"]
    wait_time = {"low": 30, "medium": 15, "high": 5, "urgent": 0}
    
    return {
        "assigned_queue": "technical_support",
        "estimated_wait_time": wait_time[priority],
        "routing_history": state.get("routing_history", []) + ["路由到技术支持"]
    }

def route_to_billing(state: CustomerServiceState):
    """账单查询队列"""
    return {
        "assigned_queue": "billing_department", 
        "estimated_wait_time": 10,
        "routing_history": state.get("routing_history", []) + ["路由到账单部门"]
    }

def route_to_complaints(state: CustomerServiceState):
    """投诉处理队列"""
    return {
        "assigned_queue": "complaints_management",
        "estimated_wait_time": 0,  # 投诉立即处理
        "routing_history": state.get("routing_history", []) + ["路由到投诉处理"]
    }

def route_to_sales(state: CustomerServiceState):
    """销售队列"""
    return {
        "assigned_queue": "sales_team",
        "estimated_wait_time": 20,
        "routing_history": state.get("routing_history", []) + ["路由到销售团队"]
    }

def route_to_general(state: CustomerServiceState):
    """通用客服队列"""
    return {
        "assigned_queue": "general_support",
        "estimated_wait_time": 25,
        "routing_history": state.get("routing_history", []) + ["路由到通用客服"]
    }

def intelligent_customer_router(state: CustomerServiceState):
    """智能客服路由"""
    intent = state["detected_intent"]
    priority = state["priority_level"]
    
    # 投诉和紧急情况优先处理
    if priority == Priority.URGENT or intent == Intent.COMPLAINT:
        return "complaints"
    elif intent == Intent.TECHNICAL_SUPPORT:
        return "technical"
    elif intent == Intent.BILLING_INQUIRY:
        return "billing"
    elif intent == Intent.SALES:
        return "sales"
    else:
        return "general"

def create_customer_service_router():
    """创建智能客服路由系统"""
    workflow = StateGraph(CustomerServiceState)
    
    # 添加节点
    workflow.add_node("analyze", analyze_user_message)
    workflow.add_node("technical", route_to_technical)
    workflow.add_node("billing", route_to_billing)
    workflow.add_node("complaints", route_to_complaints)
    workflow.add_node("sales", route_to_sales)
    workflow.add_node("general", route_to_general)
    
    # 设置流程
    workflow.set_entry_point("analyze")
    workflow.add_conditional_edges(
        "analyze",
        intelligent_customer_router,
        {
            "technical": "technical",
            "billing": "billing", 
            "complaints": "complaints",
            "sales": "sales",
            "general": "general"
        }
    )
    
    # 所有队列都是终点
    for queue in ["technical", "billing", "complaints", "sales", "general"]:
        workflow.add_edge(queue, END)
    
    return workflow.compile()

# 测试完整系统
if __name__ == "__main__":
    app = create_customer_service_router()
    
    # 测试不同类型的用户消息
    test_cases = [
        {
            "user_message": "我的应用总是崩溃，这个bug太烦人了！",
            "user_id": "user123", 
            "user_tier": "premium"
        },
        {
            "user_message": "我想了解一下你们的价格方案",
            "user_id": "user456",
            "user_tier": "basic"
        },
        {
            "user_message": "你们的服务太差了，我要投诉！",
            "user_id": "user789",
            "user_tier": "vip"
        }
    ]
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\n=== 测试案例 {i} ===")
        result = app.invoke(test_case)
        print(f"用户消息: {result['user_message']}")
        print(f"用户等级: {result['user_tier']}")
        print(f"检测意图: {result['detected_intent']}")
        print(f"优先级: {result['priority_level']}")
        print(f"分配队列: {result['assigned_queue']}")
        print(f"预计等待: {result['estimated_wait_time']}分钟")
        print(f"处理历史: {result['routing_history']}")
```

## 🎓 学习检验清单

完成本章学习后，你应该能够：

**基础能力**：
- [ ] 解释什么是条件路由，以及它解决什么问题
- [ ] 编写简单的条件函数进行二元决策
- [ ] 使用`add_conditional_edges`构建分支逻辑
- [ ] 设计合理的状态结构来支持决策

**进阶能力**：
- [ ] 实现多路径的复杂路由逻辑
- [ ] 设计和实现循环控制机制
- [ ] 优化条件函数的性能
- [ ] 调试路由逻辑的问题

**实战能力**：
- [ ] 分析业务需求，设计合适的路由策略
- [ ] 构建完整的智能路由系统
- [ ] 处理边界情况和异常状况
- [ ] 向他人解释条件路由的设计思想

## 🔮 思考题和练习

**基础练习**：
1. 修改内容处理系统，添加"中等长度内容"的处理路径
2. 实现一个简单的订单处理路由：新订单→库存检查→支付处理→发货
3. 为客服路由系统添加"工作时间"的判断逻辑

**进阶练习**：
1. 设计一个代码审查系统：检测语言→选择审查规则→执行检查→生成报告
2. 实现一个智能邮件分类器：垃圾邮件检测→重要性分级→分类标记
3. 构建一个多轮对话管理系统，根据对话历史决定下一步行动

**思考题**：
1. 什么时候应该使用复杂的条件函数，什么时候应该拆分成多个简单的决策点？
2. 如何设计状态结构才能最好地支持复杂的业务决策？
3. 在循环控制中，如何平衡"质量追求"和"效率要求"？

---

**🎯 恭喜！** 你已经掌握了让AI工作流"智能化"的核心技能。现在你的图不再是机械的步骤执行，而是能够根据情况做出灵活决策的智能系统！

**👉 下一步**: [L3: 多代理协作与工具集成](./03-多代理协作与工具集成.md) - 让多个AI代理像团队一样协作！