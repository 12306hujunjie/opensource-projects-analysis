# LangGraph 核心概念详解

## 目录
1. [状态图（StateGraph）](#状态图StateGraph)
2. [节点与边](#节点与边)
3. [通道系统](#通道系统)
4. [Pregel 执行引擎](#pregel-执行引擎)
5. [检查点机制](#检查点机制)
6. [消息与工具集成](#消息与工具集成)

## 状态图（StateGraph）

### 核心概念

StateGraph 是 LangGraph 的核心抽象，它提供了一种基于状态的方式来定义和执行工作流。与传统的函数式链不同，StateGraph 将状态作为第一等公民，所有的计算都围绕状态的读取、修改和传递进行。

### 状态定义方式

#### 1. TypedDict 方式（推荐）
```python
from typing import TypedDict, Annotated
from langgraph.graph.message import add_messages

class AgentState(TypedDict):
    messages: Annotated[list, add_messages]
    context: str
    remaining_steps: int
```

#### 2. Pydantic 模型方式
```python
from pydantic import BaseModel
from typing import Annotated

class AgentState(BaseModel):
    messages: Annotated[list, add_messages]
    context: str = ""
    remaining_steps: int = 25
    
    class Config:
        arbitrary_types_allowed = True
```

### 状态注解系统

LangGraph 使用 Python 的 `Annotated` 类型来为状态字段添加元数据：

#### 归约函数（Reducer Functions）
```python
from operator import add
from langgraph.graph.message import add_messages

# 自动列表合并
messages: Annotated[list, add_messages]

# 数值累加
total_count: Annotated[int, add]

# 自定义归约函数
def merge_contexts(existing: str, new: str) -> str:
    return f"{existing}\n---\n{new}" if existing else new

context: Annotated[str, merge_contexts]
```

#### 通道类型推断
LangGraph 会根据类型注解自动选择合适的通道类型：
- **无注解**：`LastValue` 通道
- **有归约函数**：`BinaryOperatorAggregate` 通道
- **特殊类型**：如 `Command` 类型使用 `EphemeralValue`

### 图构建API

#### 基本构建模式
```python
from langgraph.graph import StateGraph, START, END

# 创建图
graph = StateGraph(AgentState)

# 添加节点
graph.add_node("agent", call_model)
graph.add_node("tools", call_tools)

# 添加边
graph.add_edge(START, "agent")
graph.add_conditional_edges(
    "agent",
    should_continue,
    {"continue": "tools", "end": END}
)
graph.add_edge("tools", "agent")

# 编译图
app = graph.compile()
```

#### 条件边定义
```python
def should_continue(state: AgentState) -> Literal["continue", "end"]:
    messages = state["messages"]
    last_message = messages[-1]
    
    # 如果有工具调用，继续执行工具
    if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
        return "continue"
    else:
        return "end"
```

## 节点与边

### 节点类型

#### 1. 函数节点
```python
def agent_node(state: AgentState) -> dict:
    """代理节点：调用语言模型生成响应"""
    messages = state["messages"]
    response = model.invoke(messages)
    
    return {"messages": [response]}
```

#### 2. 可运行节点
```python
from langchain_core.runnables import RunnableLambda

# LangChain Runnable 作为节点
model_node = RunnableLambda(lambda state: {"messages": [model.invoke(state["messages"])]})
graph.add_node("model", model_node)
```

#### 3. 类方法节点
```python
class AgentTools:
    def __init__(self):
        self.tools = [search_tool, calculator_tool]
    
    def call_tools(self, state: AgentState) -> dict:
        # 工具调用逻辑
        return {"messages": tool_responses}

agent_tools = AgentTools()
graph.add_node("tools", agent_tools.call_tools)
```

### 边类型详解

#### 1. 普通边（Normal Edges）
```python
# 无条件边：从 A 总是流向 B
graph.add_edge("node_a", "node_b")
graph.add_edge(START, "first_node")
graph.add_edge("last_node", END)
```

#### 2. 条件边（Conditional Edges）
```python
def route_decision(state: AgentState) -> str:
    if state["confidence"] > 0.8:
        return "high_confidence_path"
    elif state["confidence"] > 0.5:
        return "medium_confidence_path"
    else:
        return "low_confidence_path"

graph.add_conditional_edges(
    "decision_node",
    route_decision,
    {
        "high_confidence_path": "fast_process",
        "medium_confidence_path": "normal_process", 
        "low_confidence_path": "careful_process"
    }
)
```

#### 3. 动态边（使用 Send）
```python
from langgraph.types import Send

def fan_out(state: AgentState) -> list[Send]:
    """根据状态动态创建多个并行任务"""
    items = state["items_to_process"]
    
    return [
        Send("process_item", {"item": item, "index": i})
        for i, item in enumerate(items)
    ]

graph.add_conditional_edges(START, fan_out)
```

### 节点执行模型

#### 输入映射
```python
# LangGraph 自动将状态映射到节点函数参数
def my_node(state: AgentState) -> dict:
    # state 包含完整的图状态
    messages = state["messages"]
    context = state["context"]
    # ... 处理逻辑
    
    # 返回状态更新字典
    return {
        "messages": [new_message],
        "context": updated_context
    }
```

#### 输出合并
节点的返回值会自动与现有状态合并：
```python
# 假设当前状态
current_state = {
    "messages": [msg1, msg2],
    "context": "existing context",
    "step": 5
}

# 节点返回
node_output = {
    "messages": [msg3],  # 会通过 add_messages 合并
    "step": 6           # 会覆盖现有值
}

# 合并后状态
merged_state = {
    "messages": [msg1, msg2, msg3],  # 列表合并
    "context": "existing context",   # 未修改
    "step": 6                        # 更新值
}
```

## 通道系统

### 通道架构

通道（Channel）是 LangGraph 状态管理的核心组件，提供了节点间通信的抽象层。每个状态字段对应一个通道，通道负责值的存储、更新和版本管理。

### 通道类型详解

#### 1. LastValue 通道
最常用的通道类型，存储单一值：

```python
class LastValue(BaseChannel):
    """存储最后写入的值，支持类型检查"""
    
    def __init__(self, typ: Type, key: str):
        self.typ = typ
        self.key = key
        self.value = MISSING
    
    def update(self, values: list[Any]) -> None:
        if len(values) > 1:
            raise InvalidUpdateError("LastValue 只能接受一个值")
        self.value = values[0] if values else MISSING
```

#### 2. BinaryOperatorAggregate 通道
使用归约函数合并多个值：

```python
class BinaryOperatorAggregate(BaseChannel):
    """使用二元操作符合并值"""
    
    def __init__(self, typ: Type, reducer: Callable[[Any, Any], Any]):
        self.typ = typ
        self.reducer = reducer
        self.value = MISSING
    
    def update(self, values: list[Any]) -> None:
        if not values:
            return
            
        if self.value is MISSING:
            self.value = values[0]
            values = values[1:]
            
        for value in values:
            self.value = self.reducer(self.value, value)
```

#### 3. Topic 通道
支持发布-订阅模式：

```python
class Topic(BaseChannel):
    """发布-订阅通道，支持多个订阅者"""
    
    def __init__(self, typ: Type, accumulate: bool = False):
        self.typ = typ
        self.accumulate = accumulate
        self.values = []
    
    def update(self, values: list[Any]) -> None:
        if self.accumulate:
            self.values.extend(values)
        else:
            self.values = values.copy()
```

#### 4. EphemeralValue 通道
临时值存储，不持久化：

```python
class EphemeralValue(BaseChannel):
    """临时值通道，不参与检查点"""
    
    def checkpoint(self) -> Any:
        return None  # 不保存到检查点
    
    def from_checkpoint(self, checkpoint: Any) -> Self:
        return self.__class__(self.typ, self.key)  # 总是返回空实例
```

### 通道版本管理

每个通道都有版本管理机制：

```python
class ChannelVersions:
    """通道版本跟踪"""
    
    def __init__(self):
        self._versions: dict[str, Union[int, float]] = {}
    
    def get(self, channel: str, default: Union[int, float] = 0) -> Union[int, float]:
        return self._versions.get(channel, default)
    
    def increment(self, channel: str, by: Union[int, float] = 1) -> None:
        current = self.get(channel)
        self._versions[channel] = current + by
```

### 通道触发机制

节点通过监听通道更新来触发执行：

```python
def _triggers(channels, versions, seen, null_version, proc):
    """判断进程是否应该基于通道更新运行"""
    if seen is None:
        # 首次执行 - 检查任何触发通道是否有数据
        return any(channels[chan].is_available() for chan in proc.triggers)
    else:
        # 后续执行 - 检查版本更新
        return any(
            channels[chan].is_available() and 
            versions.get(chan, null_version) > seen.get(chan, null_version)
            for chan in proc.triggers
        )
```

## Pregel 执行引擎

### Pregel 算法概述

LangGraph 的执行引擎基于 Google Pregel 算法，这是一个面向图处理的批量同步并行计算模型。

### 超步执行模型

#### 超步结构
```python
class PregelLoop:
    """Pregel 执行循环"""
    
    def tick(self) -> bool:
        """执行一个超步"""
        # 1. 准备任务
        self.tasks = prepare_next_tasks(
            self.channels, 
            self.managed, 
            self.config
        )
        
        # 2. 检查中断
        if should_interrupt(self.checkpoint, self.tasks):
            raise GraphInterrupt(self.tasks)
        
        # 3. 返回是否有更多任务
        return len(self.tasks) > 0
```

#### 任务类型

**PULL 任务（节点触发）**：
```python
@dataclass
class PregelTaskWrites:
    name: str
    path: tuple[str, ...]
    writes: list[tuple[str, Any]]
    triggers: list[str]
```

**PUSH 任务（Send 消息）**：
```python
def handle_send_message(send: Send) -> PregelTaskWrites:
    """处理 Send 消息，创建 PUSH 任务"""
    return PregelTaskWrites(
        name=send.node,
        path=(PUSH, send.node, str(uuid.uuid4())),
        writes=[],
        triggers=[]
    )
```

### 并行执行策略

#### 任务调度算法
```python
def prepare_next_tasks(channels, managed, config):
    """准备下一个超步的所有任务"""
    tasks = []
    
    # 1. 检查 Send 任务（PUSH）
    if (tasks_channel := channels.get(TASKS)) and tasks_channel.is_available():
        for send in tasks_channel.get():
            tasks.append(create_push_task(send))
    
    # 2. 检查触发的节点（PULL）
    triggered_nodes = find_triggered_nodes(channels, managed)
    for node_name in triggered_nodes:
        tasks.append(create_pull_task(node_name))
    
    return tasks
```

#### 并行执行实现
```python
def execute_tasks_parallel(tasks: list[PregelTaskWrites]) -> list[PregelTaskWrites]:
    """并行执行所有任务"""
    with ThreadPoolExecutor() as executor:
        futures = {
            executor.submit(execute_task, task): task 
            for task in tasks
        }
        
        results = []
        for future in as_completed(futures):
            try:
                result = future.result()
                results.append(result)
            except Exception as e:
                # 错误处理
                handle_task_error(futures[future], e)
        
        return results
```

### 状态同步机制

#### 写入应用算法
```python
def apply_writes(checkpoint, channels, tasks, get_next_version):
    """原子性应用所有任务的写入操作"""
    
    # 1. 按路径排序确保确定性执行
    tasks = sorted(tasks, key=lambda t: task_path_str(t.path[:3]))
    
    # 2. 计算下一版本号
    max_version = max(checkpoint["channel_versions"].values(), default=0)
    next_version = get_next_version(max_version, None)
    
    # 3. 收集所有写入操作
    pending_writes = defaultdict(list)
    for task in tasks:
        for channel, value in task.writes:
            pending_writes[channel].append(value)
    
    # 4. 原子性应用写入
    for channel, values in pending_writes.items():
        channels[channel].update(values)
        checkpoint["channel_versions"][channel] = next_version
    
    return next_version
```

## 检查点机制

### 检查点数据结构

```python
class Checkpoint(TypedDict):
    """检查点完整数据结构"""
    v: int                              # 格式版本
    id: str                            # UUID6 检查点ID
    ts: str                            # ISO 时间戳
    channel_values: dict[str, Any]     # 序列化的通道状态
    channel_versions: ChannelVersions  # 每通道版本跟踪
    versions_seen: dict[str, ChannelVersions]  # 节点执行跟踪
    updated_channels: list[str] | None # 本步修改的通道
```

### 版本管理系统

#### UUID6 时间戳排序
```python
import uuid
from datetime import datetime

def generate_checkpoint_id(step: int = 0) -> str:
    """生成带时间戳的检查点ID"""
    # UUID6 包含单调递增时间戳
    timestamp = datetime.utcnow().timestamp()
    return str(uuid.uuid6(uuid.uuid1(), timestamp))
```

#### 增量版本控制
```python
class VersionManager:
    def get_next_version(self, current_max: int, step: int = None) -> int:
        """计算下一版本号"""
        if step is not None:
            return step
        return current_max + 1
    
    def should_checkpoint(self, versions_diff: int) -> bool:
        """决定是否创建检查点"""
        return versions_diff > 0  # 有任何更新就创建检查点
```

### 序列化策略

#### 通道序列化
```python
class BaseChannel:
    def checkpoint(self) -> Any:
        """序列化通道状态用于检查点"""
        raise NotImplementedError
    
    def from_checkpoint(self, checkpoint: Any) -> Self:
        """从检查点反序列化通道"""
        raise NotImplementedError

# LastValue 实现
class LastValue(BaseChannel):
    def checkpoint(self) -> Any:
        return self.value if self.value is not MISSING else MISSING
    
    def from_checkpoint(self, checkpoint: Any) -> Self:
        empty = self.__class__(self.typ, self.key)
        if checkpoint is not MISSING:
            empty.value = checkpoint
        return empty
```

#### 序列化器插件系统
```python
class SerializerProtocol(Protocol):
    def dumps(self, obj: Any) -> bytes: ...
    def loads(self, data: bytes) -> Any: ...

class JsonPlusSerializer:
    """默认 JSON+ 序列化器，支持二进制数据"""
    
    def dumps(self, obj: Any) -> bytes:
        return orjson.dumps(
            obj, 
            default=self._encode_default,
            option=orjson.OPT_NON_STR_KEYS | orjson.OPT_SERIALIZE_UUID
        )
    
    def loads(self, data: bytes) -> Any:
        return orjson.loads(data)
```

### 持久化后端

#### 基础接口
```python
class BaseCheckpointSaver(ABC):
    """检查点保存器基类"""
    
    @abstractmethod
    def put(
        self, 
        config: RunnableConfig, 
        checkpoint: Checkpoint, 
        metadata: dict, 
        new_versions: ChannelVersions
    ) -> RunnableConfig:
        """保存检查点"""
        pass
    
    @abstractmethod
    def get_tuple(self, config: RunnableConfig) -> CheckpointTuple | None:
        """获取检查点元组"""
        pass
    
    @abstractmethod
    def list(
        self, 
        config: RunnableConfig, 
        *, 
        filter: dict | None = None,
        before: RunnableConfig | None = None,
        limit: int | None = None
    ) -> Iterator[CheckpointTuple]:
        """列出检查点历史"""
        pass
```

#### 实现示例（内存后端）
```python
class MemoryCheckpointSaver(BaseCheckpointSaver):
    def __init__(self):
        self.storage: dict[tuple[str, str], CheckpointTuple] = {}
    
    def put(self, config, checkpoint, metadata, new_versions):
        thread_id = config["configurable"]["thread_id"]
        checkpoint_id = checkpoint["id"]
        key = (thread_id, checkpoint_id)
        
        self.storage[key] = CheckpointTuple(
            config=config,
            checkpoint=checkpoint,
            metadata=metadata,
            parent_config=config.get("configurable", {}).get("checkpoint_id")
        )
        
        return patch_configurable(config, {"checkpoint_id": checkpoint_id})
```

## 消息与工具集成

### 消息处理系统

#### 消息类型支持
```python
from langchain_core.messages import (
    BaseMessage, AIMessage, HumanMessage, 
    SystemMessage, ToolMessage, FunctionMessage
)

# 自动消息合并
def add_messages(left: list[BaseMessage], right: list[BaseMessage]) -> list[BaseMessage]:
    """智能合并消息列表"""
    if not left:
        return right
    if not right:
        return left
    
    # 合并逻辑：处理 tool_calls 和对应的 ToolMessage
    merged = left.copy()
    
    for message in right:
        if isinstance(message, AIMessage) and message.tool_calls:
            # AI 消息带工具调用
            merged.append(message)
        elif isinstance(message, ToolMessage):
            # 工具响应消息
            merged.append(message) 
        else:
            # 其他类型消息
            merged.append(message)
    
    return merged
```

### 工具集成模式

#### ToolNode 架构
```python
class ToolNode(RunnableLambda):
    """工具节点：执行工具调用并返回结果"""
    
    def __init__(
        self, 
        tools: Sequence[Union[BaseTool, Callable]],
        *,
        name: str = "tools",
        tags: list[str] | None = None,
        handle_tool_errors: bool = True
    ):
        self.tools_by_name = {tool.name: tool for tool in tools}
        self.name = name
        self.handle_tool_errors = handle_tool_errors
        
        super().__init__(
            self._func,
            name=name,
            tags=tags or []
        )
    
    def _func(self, input: dict, config: RunnableConfig) -> dict:
        """执行工具调用"""
        message = input["messages"][-1]
        
        if not hasattr(message, 'tool_calls') or not message.tool_calls:
            raise ValueError("没有工具调用需要执行")
        
        # 并行执行所有工具调用
        with ThreadPoolExecutor() as executor:
            futures = {
                executor.submit(self._execute_tool, tool_call, config): tool_call
                for tool_call in message.tool_calls
            }
            
            tool_messages = []
            for future in as_completed(futures):
                tool_call = futures[future]
                try:
                    result = future.result()
                    tool_messages.append(ToolMessage(
                        content=str(result),
                        tool_call_id=tool_call["id"]
                    ))
                except Exception as e:
                    if self.handle_tool_errors:
                        tool_messages.append(ToolMessage(
                            content=f"工具执行出错: {str(e)}",
                            tool_call_id=tool_call["id"]
                        ))
                    else:
                        raise
        
        return {"messages": tool_messages}
```

#### 参数注入机制
```python
def tool_with_state(x: int, state: AgentState, config: RunnableConfig) -> str:
    """工具函数可以接受状态和配置参数"""
    context = state.get("context", "")
    return f"处理 {x}，上下文：{context}"

# LangGraph 自动注入这些参数
tool_node = ToolNode([tool_with_state])
```

### 预构建代理模式

#### create_react_agent 实现原理
```python
def create_react_agent(
    model: LanguageModelLike,
    tools: Sequence[Union[BaseTool, Callable]],
    *,
    state_schema: Optional[Type] = None,
    messages_modifier: Optional[Union[str, Runnable]] = None,
    checkpointer: Optional[BaseCheckpointSaver] = None,
    interrupt_before: Optional[list[str]] = None,
    interrupt_after: Optional[list[str]] = None,
) -> CompiledStateGraph:
    """创建 ReAct 模式代理"""
    
    # 1. 状态模式设置
    if state_schema is None:
        state_schema = MessagesState
    
    # 2. 工具绑定
    if tools and hasattr(model, 'bind_tools'):
        model = model.bind_tools(tools)
    
    # 3. 图构建
    graph = StateGraph(state_schema)
    
    # 4. 添加核心节点
    graph.add_node("agent", _create_agent_node(model, messages_modifier))
    if tools:
        graph.add_node("tools", ToolNode(tools))
    
    # 5. 添加边
    graph.add_edge(START, "agent")
    if tools:
        graph.add_conditional_edges(
            "agent",
            _should_continue,
            {"continue": "tools", "end": END}
        )
        graph.add_edge("tools", "agent")
    else:
        graph.add_edge("agent", END)
    
    # 6. 编译
    return graph.compile(
        checkpointer=checkpointer,
        interrupt_before=interrupt_before,
        interrupt_after=interrupt_after
    )
```

这些核心概念构成了 LangGraph 的基础架构，理解它们对于有效使用 LangGraph 构建复杂 AI 应用至关重要。每个概念都有其特定的用途和最佳实践，在实际应用中需要根据具体需求进行选择和组合。