# L2.1: 请求生命周期 - 入口与请求对象的诞生

这是对 Flask 请求生命周期系列分析的第一部分。在 L1 中，我们理解了 Flask 是一个遵循 WSGI 规范的“胶水”框架。现在，我们将深入流程的起点：一个 HTTP 请求是如何进入 Flask，以及 Flask 是如何将原始、丑陋的 WSGI `environ` 字典，转化为我们熟悉且喜爱的、功能强大的 `request` 对象的。

## 1. WSGI 入口: `Flask.wsgi_app`

一切始于 `Flask.wsgi_app(self, environ, start_response)` 方法。根据 [PEP 3333 (WSGI 1.0.1)](https://peps.python.org/pep-3333/) 规范，任何 WSGI 应用都必须是一个可调用对象，它接收两个参数：

1.  `environ`: 一个包含 CGI 风格环境变量的字典。它描述了请求的所有信息，如 HTTP 方法、服务器名、路径、查询字符串、HTTP 头等。
2.  `start_response`: 一个可调用对象，用于发送 HTTP 状态码和响应头。

当一个 WSGI 兼容的服务器（如 Gunicorn, uWSGI）收到一个 HTTP 请求时，它会解析该请求，将信息填入 `environ` 字典，然后调用 `app.wsgi_app(environ, start_response)`。

## 2. 请求对象的创建：从字典到对象

`wsgi_app` 的首要职责之一，就是将原始的 `environ` 字典包装成一个更友好、更强大的对象。这个过程发生在 `wsgi_app` 方法的开头：

```python
# flask/app.py

def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:
    # 1. 创建请求上下文，这是关键的第一步
    ctx = self.request_context(environ)
    # ... 后续步骤
```

让我们深入 `self.request_context(environ)`:

```python
# flask/app.py

def request_context(self, environ: dict) -> "RequestContext":
    # 2. 使用 self.request_class (默认为 werkzeug.Request) 创建请求对象
    request = self.request_class(environ)
    # 3. 将创建好的 request 对象传入 RequestContext 的构造函数
    return RequestContext(self, environ, request=request)
```

这里的流程非常清晰：

1.  `wsgi_app` 调用 `request_context`。
2.  `request_context` 使用 `self.request_class` 来实例化一个请求对象。默认情况下，`self.request_class` 就是 `werkzeug.wrappers.Request`。
3.  这个 `Request` 类接收原始的 `environ` 字典作为其构造函数的参数，并将其解析成一系列方便的属性和方法（如 `request.method`, `request.args`, `request.headers` 等）。
4.  最后，这个新创建的 `request` 对象被存储在 `RequestContext` 中，等待后续使用。

## 3. `request_class` 的角色

`Flask.request_class` 属性是一个重要的定制点。虽然默认的 `werkzeug.Request` 已经非常强大，但 Flask 允许开发者通过子类化 `werkzeug.Request` 并将其赋值给 `app.request_class`，来为请求对象添加自定义的功能。

例如，你可以添加一个自定义属性来解析特定的认证头：

```python
from werkzeug.wrappers import Request as BaseRequest

class MyRequest(BaseRequest):
    @property
    def user_token(self):
        return self.headers.get('X-User-Token')

app = Flask(__name__)
app.request_class = MyRequest

@app.route('/profile')
def profile():
    # 现在你可以直接访问 request.user_token
    token = request.user_token
    ...
```

## 4. Ultra Think: 封装 `environ` 的深刻意义

为什么不直接操作 `environ` 字典，而是要大费周章地将其封装成一个对象？这背后是软件工程中一个极其重要的原则：**抽象与封装**。

1.  **从“数据”到“行为”的升华**：`environ` 只是一个被动的数据结构（一个字典）。而 `werkzeug.Request` 是一个拥有**行为**的对象。它不仅存储数据，还提供了处理这些数据的方法（如 `request.get_json()`，`request.form` 的解析等）。这使得与请求相关的逻辑可以被内聚到请求对象本身，而不是散落在业务代码中。

2.  **建立稳定的契约**：直接操作 `environ` 字典会让你的应用代码与底层的 WSGI 协议实现紧密耦合。`environ` 中的键名是大小写敏感的字符串，容易出错。`Request` 对象提供了一个稳定、可靠的属性式访问接口（`request.method` vs `environ['REQUEST_METHOD']`），这个接口就是框架与开发者之间的“契约”，它隐藏了底层的实现细节，使得代码更具可读性和可维护性。

3.  **提升可测试性**：创建一个 `Request` 对象远比手动构建一个完整的 `environ` 字典要简单得多。在单元测试中，你可以轻松地实例化一个 `Request` 对象来模拟不同的请求场景，而无需关心 `environ` 的所有细节。

4.  **面向未来的设计**：如果未来的 Web 协议（如 HTTP/3）带来了新的底层数据结构，理论上只需要更新 `Request` 类的内部实现，而上层的应用代码可以保持不变。这就是封装带来的巨大威力。

**结论**：将 `environ` 封装成 `Request` 对象，是 Flask（以及几乎所有现代 Python Web 框架）迈出的第一步，也是最重要的一步。它奠定了整个框架优雅、健壮和可扩展的基石。

---

接下来，在 **`02.2-L2-Context-Creation.md`** 中，我们将继续沿着 `wsgi_app` 的执行路径，探索 `RequestContext` 和 `AppContext` 是如何被创建和推入栈中，从而激活我们所熟知的 `request` 代理对象的。